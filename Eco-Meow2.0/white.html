<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>White Kitty</title>

    <style>
        body{
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <script type="module">
        import {OrbitControls} from './libs/OrbitControls.js'
        import * as THREE from './libs/three.module.js';
        import * as BufferGeometryUtils from './libs/BufferGeometryUtils.js';

        let controls;
        let camera, scene, renderer;

        let keyPressed, rightKey, leftKey, upKey, downKey;
        
        // let shoulderl, elbowl, shoulderr, elbowr;
        // let legl, legr, armUpl, armUpr, forearml, forearmr, earl, earr, tail;
        // let features, bell, whiteKitty, whiteKittybody, armsl, armsr;
        let  whiteKitty;
        let bg, whiteCat;

        window.onload = function init() {

            scene = new THREE.Scene();
            
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 50); // perspective camera
            
            camera.position.z = 13;
            camera.position.x = 1;
            camera.position.y = 3;

            camera.lookAt(scene.position); //point the camera to the center of the scene
            
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight); // set output canvas and viewport size
            
            controls = new OrbitControls(camera, renderer.domElement);

            // configure renderer clear color
            renderer.setClearColor("#9BD4C3");
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // add the output of the renderer to an HTML element (adds a Canvas element to the body)
            document.body.appendChild(renderer.domElement);

            // const axeHelper = new THREE.AxesHelper(5);
            // scene.add(axeHelper);

            //-----------------------------------------------------
            // lights

            // let light = new THREE.AmbientLight(0xffffff, 0.7);
            let light = new THREE.AmbientLight(0xFFFFFF, 0.7);
            scene.add(light);

            let light2 = new THREE.PointLight(0xEAE178, 0.7, 100 );
            light2.position.set(-15, 6, 5);
            light2.castShadow = true;
            light2.shadow.camera;
            scene.add(light2);

            let light3 = new THREE.PointLight(0xEEBA77, 0.8,100);
            light3.position.set(5, 8, 5);
            scene.add(light3);
            // light helper
            let pointLightHelper = new THREE.PointLightHelper(light2, 0.4);
            let pointLightHelper1 = new THREE.PointLightHelper(light3, 0.4);
            // pointLightHelper.name = "helper";
            // scene.add(pointLightHelper);
            // scene.add(pointLightHelper1);

            // --------------------------------------------------------
            // colors
            const colorGreenShade = new THREE.MeshPhongMaterial({color: 0xA4C263, flatShading:true, shininess: 0});
            const colorBege = new THREE.Color(0xF3F2C0);
            const colorBlush = new THREE.Color(0xEFC5DE);
            const colorPink = new THREE.Color(0xE8B5AC);
            const colorLightPurple = new THREE.Color(0xdaccff);
            const colorDarkPurple = new THREE.Color(0x766DAA);
            const colorYellow = new THREE.Color(0xECE26B);
            const colorBlack = new THREE.Color(0x000000);
            // const colorGreen = new THREE.Color(0xA4C263);
            // const colorRocks = new THREE.Color(0x9DA89A);
            // const colorGray = new THREE.Color(0x494949);
            // const colorWhite = new THREE.Color(0xF7F7F2);

            // ----------------------------------------------
            // background
            let material = new THREE.MeshBasicMaterial({
                color: 0x4b4b4b,
                wireframe: false,
            });
            
            // ground
            let geometry = new THREE.BoxGeometry(30, 1.5, 30)
            let plane = new THREE.Mesh(geometry, colorGreenShade);
            plane.position.y = -1.5;
            plane.position.z = -9;
            plane.receiveShadow = true;
            scene.add(plane);

            // -------------------------------------------------- 
            // white cat 

            let whiteCatGeometries = [];

            const wBody = new THREE.BoxGeometry(1.5, 1, 1);
            const colorsBege = []; // array of colors for each vertex of the geometry
            // Do this ONLY ONCE, since ALL 3 level catGeometries have the SAME number of vertices
            for (let i = 0; i < wBody.attributes.position.count; i++)
                colorsBege.push(colorBege.r, colorBege.g, colorBege.b);

            // head
            const wHead = new THREE.BoxGeometry(2.25, 1.7, 1.6);
            wHead.translate(0, 1.55, 0)
            wHead.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBege), 3));
            whiteCatGeometries.push(wHead);
            
            // snout
            const wSnout = new THREE.BoxGeometry(2, 0.65, 0.25);
            wSnout.translate(0, 1.02, 0.87)
            wSnout.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBege), 3));
            whiteCatGeometries.push(wSnout);
            
            // body
            wBody.translate(0, 0.2, 0)
            wBody.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBege), 3));
                whiteCatGeometries.push(wBody);
                
            // forehead
            const wForehead = new THREE.BoxGeometry(0.85, 0.5, 1.62);
            const colorsLightPurple = []; 
            for (let i = 0; i < wBody.attributes.position.count; i++)
                colorsLightPurple.push(colorLightPurple.r, colorLightPurple.g, colorLightPurple.b);
            wForehead.translate(0, 2.16,0);
            wForehead.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLightPurple), 3));
            whiteCatGeometries.push(wForehead);
            
            // colar
            const wColar = new THREE.BoxGeometry(1.7, 0.5, 1.2);
            const colorsDarkPurple = [];
            for (let i = 0; i < wBody.attributes.position.count; i++)
                colorsDarkPurple.push(colorDarkPurple.r, colorDarkPurple.g, colorDarkPurple.b);
            wColar.translate(0, 0.7, 0);
            wColar.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsDarkPurple), 3));
            whiteCatGeometries.push(wColar);    
               
            // blush
            const wBlushL = new THREE.BoxGeometry(0.3, 0.18, 0.05);
            const colorsBlush = [];
            for (let i = 0; i < wBody.attributes.position.count; i++)
                colorsBlush.push(colorBlush.r, colorBlush.g, colorBlush.b);
            wBlushL.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBlush), 3));
            wBlushL.translate(0.845, 0.79, 1);
            const wBlushR = wBlushL.clone();
            wBlushR.translate(-1.685,0,0)
            whiteCatGeometries.push(wBlushL, wBlushR);

            // mouth
            
            // ears
            const wEarL = new THREE.BoxGeometry();

            // bell
            const wBell = new THREE.SphereGeometry(0.2, 10, 10);
            const colorsYellow = [];
            for (let i = 0; i < wBody.attributes.position.count; i++)
                colorsYellow.push(colorYellow.r, colorYellow.g, colorYellow.b);
            wBell.translate(0, 0.4, 0.7);
            wBell.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsYellow), 3));
            whiteCatGeometries.push(wBell);

            
            

            // whiskers left
            const wWhiskersL = new THREE.CylinderGeometry(0.03, 0.03, 0.5,20,1);
            const colorsBlack = [];
            for (let i = 0; i < wBody.attributes.position.count; i++)
                colorsBlack.push(colorBlack.r, colorBlack.g, colorBlack.b);
            wWhiskersL.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBlack), 3));
            wWhiskersL.translate(0.9, 1.2, 0.7);
            wWhiskersL.rotateZ(1.6,0,0);
            const wWhiskersL2 = wWhiskersL.clone();
            wWhiskersL2.translate(0, 0.25,0);
            whiteCatGeometries.push(wWhiskersL, wWhiskersL2);

            // whiskers right
            const wWhiskersR = new THREE.CylinderGeometry(0.03, 0.03, 0.5,20,1);
            wWhiskersR.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBlack), 3));
            wWhiskersR.translate(0.9, -1.2, 0.7);
            wWhiskersR.rotateZ(1.6,0,0);
            const wWhiskersR2 = wWhiskersR.clone();
            wWhiskersR2.translate(0, 0.25,0);
            whiteCatGeometries.push(wWhiskersR, wWhiskersR2);

            // eyes 
            const wEyeL = new THREE.SphereGeometry(0.13,10,10);
            wEyeL.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBlack), 3));
            wEyeL.translate(-0.6, 1.45, 0.8);
            const wEyeR = wEyeL.clone();
            wEyeR.translate(1.2,0,0);
            whiteCatGeometries.push(wEyeL, wEyeR);

                

            


            




            whiteCatGeometries = BufferGeometryUtils.mergeBufferGeometries(whiteCatGeometries);
            
            const whiteCat = new THREE.Mesh(
                whiteCatGeometries,
                new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    flatShading: true,
                    shininess: 0,
                })
            );

            whiteCat.castShadow = true;
            whiteCat.receiveShadow = true;
            
            whiteKitty = new THREE.Group();
            whiteKitty.add(whiteCat);
            // whiteKitty.add(whiteCat, leg1, leg2, arm1, arm2, oMouth);
            scene.add(whiteKitty);


            renderer.setAnimationLoop(render);

            function render() {
                renderer.render(scene, camera);
            }

        }

    </script>
</body>