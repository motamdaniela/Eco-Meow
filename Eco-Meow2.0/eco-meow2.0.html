<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>
        body{
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    
    <script type="module">
        import {OrbitControls} from './libs/OrbitControls.js'
        import * as THREE from './libs/three.module.js';
        import * as BufferGeometryUtils from './libs/BufferGeometryUtils.js';

        // const geometry = new BufferGeometry();
        let controls;
        let camera, scene, renderer;

        let keyPressed, rightKey, leftKey, upKey, downKey, toShake, toFall;
        let started = false;

        let heart, tree, treeTop, indicator, spot;
        
        let shoulderl, elbowl, shoulderr, elbowr;
        let legl, legr, armUpl, armUpr, forearml, forearmr, earl, earr, tail;
        let features, bell, blackKitty, blackKittybody, armsl, armsr;
        let bg, blackCat;
        let verts = []; let vertsTree = [];

        // let initialRot =[]
        
        window.onload = function init() {
            scene = new THREE.Scene();
            
            
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 50); // perspective camera
            
            camera.position.z = 13;
            camera.position.x = 1;
            camera.position.y = 3;

            camera.lookAt(scene.position); //point the camera to the center of the scene
            
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight); // set output canvas and viewport size
            
            controls = new OrbitControls(camera, renderer.domElement);
            
            // configure renderer clear color
            renderer.setClearColor("#9BD4C3");
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // add the output of the renderer to an HTML element (adds a Canvas element to the body)
            document.body.appendChild(renderer.domElement);

            // const axeHelper = new THREE.AxesHelper(5);
            // scene.add(axeHelper);

        //----------------------------------------------------------------
// lights
            // let light = new THREE.AmbientLight(0xffffff, 0.7);
            let light = new THREE.AmbientLight(0xEAE178, 0.7);
            scene.add(light);

            let light2 = new THREE.PointLight(0xEAE178, 0.7, 100 );
            light2.position.set(-15, 6.5, 7);
            light2.castShadow = true;
            light2.shadow.camera;
            scene.add(light2);

            

            let light3 = new THREE.PointLight(0xEEBA77, 0.8,100);
            light3.position.set(5, 8, 5);
            scene.add(light3);
            // light helper
            let pointLightHelper = new THREE.PointLightHelper(light2, 0.4);
            let pointLightHelper1 = new THREE.PointLightHelper(light3, 0.4);
            // pointLightHelper.name = "helper";
            // scene.add(pointLightHelper);
            // scene.add(pointLightHelper1);

// ----------
// colors
const colorGreenShade = new THREE.MeshPhongMaterial({color: 0xA4C263, flatShading:true, shininess: 0});
        const colorGreen = new THREE.Color(0xA4C263);
        const colorBrown = new THREE.Color(0x8C7369);
        const colorRocks = new THREE.Color(0x9DA89A);
        const colorGray = new THREE.Color(0x494949);
        const colorBlack = new THREE.Color(0x000000);
        const colorWhite = new THREE.Color(0xF7F7F2);
        const colorPink = new THREE.Color(0xE8B5AC);
        const colorPurple = new THREE.Color(0x8F76D4);
        const colorYellow = new THREE.Color(0xEAE178);
        const colorRed = new THREE.Color(0xBD757E);

//pointer
let ind = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, 0.5),
          new THREE.MeshPhongMaterial({
            color: colorGreen,
            flatShading: true,
            shininess: 0,
          })
        );
        ind.position.y = 2.7;

        let ind2 = new THREE.Mesh(
          new THREE.CylinderGeometry(0.15, 0.1, 0.5),
          new THREE.MeshPhongMaterial({
            color: colorGreen,
            flatShading: true,
            shininess: 0,
          })
        );
        ind2.position.x = -0.2;
        ind2.position.y = 3;
        ind2.rotation.z = 1;

        let ind3 = ind2.clone();
        ind3.position.x = 0.2;
        ind3.rotation.z = -1;

        indicator = new THREE.Group();
        indicator.add(ind, ind2, ind3);
        indicator.position.y = -0.15;
        indicator.position.y = 1;
        scene.add(indicator);


        //-------------

            const heartl = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 6,6),
                new THREE.MeshStandardMaterial({ color: colorRed, flatShading: true, roughness: 0.4})
            );
            heartl.rotateZ(0.6,0,0);
            heartl.position.x = -0.35;
            heartl.position.y = 3.8;
            const heartr = heartl.clone();
            heartr.position.x = 0.35;
            heartr.rotateZ(-1.2,0,0)
            const heartbase = heartl.clone();
            heartbase.position.y = 3.45;
            heartbase.position.x = 0;
            heartbase.rotateZ(-0.6,0,0)
            
            const midl = new THREE.Mesh(
                new THREE.CylinderGeometry(0.499, 0.5, 0.5, 6),
                new THREE.MeshStandardMaterial({ color: colorRed, flatShading: true, roughness: 0.4})
            );
            midl.rotateZ(0.8,0,0);
            midl.rotateY(1.6,0,0);
            midl.position.x = -0.2;
            midl.position.y = 3.65;
            const midr = midl.clone();
            midr.rotateZ(-3.2,0,0);
            midr.rotateX(-1.6,0,0);
            midr.position.x = 0.2;
            
            heartl.castShadow = heartl.receiveShadow = true;
            heartr.castShadow = heartr.receiveShadow = true;
            midl.castShadow = midl.receiveShadow = true;
            midr.castShadow = midr.receiveShadow = true;
            
            let leaf = indicator.clone();
            leaf.scale.set(0.8,0.8,0.8)
            leaf.position.y = 2;
            heart = new THREE.Group();
            heart.add(heartl, heartr,heartbase, midl, midr, leaf);
            heart.castShadow = heart.receiveShadow = true;

// background
            
            // ground
            let geometry = new THREE.BoxGeometry(35, 1.5, 35)
            let plane = new THREE.Mesh(geometry, colorGreenShade);
            plane.position.y = -1.5;
            plane.position.z = -9;
            plane.receiveShadow = true;
            scene.add(plane);

//spot to plant the tree
            let texture = new THREE.TextureLoader().load ('./libs/spot.png');
            let material = new THREE.MeshPhongMaterial({ map: texture, shininess: 0});

            spot = new THREE.Mesh(
                new THREE.PlaneGeometry(9,9),
                material
            )
            spot.rotation.x = THREE.Math.degToRad(-90);
            spot.position.set(0,-0.7,-7);
            spot.receiveShadow = true;
            scene.add(spot);


// tree thats gonna get planted
            const treeGeometries = []                
            const colorTree = [];
                const treeupPart = new THREE.TorusGeometry(2.3,1.5,10,15);
                for (let i = 0; i < treeupPart.attributes.position.count; i++)
                colorTree.push(colorGreen.r, colorGreen.g, colorGreen.b);
                // add color attribute to the upPart buffer geometry
                treeupPart.setAttribute(
                    'color',
                    new THREE.BufferAttribute(new Float32Array(colorTree), 3));
                const treedownPart = new THREE.TorusGeometry(2.3,1.5,10,15);
                    treedownPart.setAttribute(
                        'color',
                        new THREE.BufferAttribute(new Float32Array(colorTree), 3));

            treeupPart.rotateX(1.6,0,0); treedownPart.rotateX(1.6,0,0);
            treedownPart.translate(0,4.5,0);treeupPart.translate(0,6,0);
            treeGeometries.push(treeupPart,treedownPart)

            treeTop = new THREE.Mesh(
               BufferGeometryUtils.mergeBufferGeometries(treeGeometries),
               new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0})
           )

            const treeTrunk = new THREE.Mesh(
                new THREE.BoxGeometry(2.5, 5.5, 2.5),
                new THREE.MeshPhongMaterial({ color: colorBrown, flatShading: true, shininess: 0}))

            treeTrunk.position.y = 0.6;
                
                treeTop.receiveShadow = treeTop.castShadow = true;
                treeTrunk.castShadow = treeTrunk.receiveShadow = true;

                const insidePart = new THREE.Mesh(
                new THREE.BoxGeometry(6, 3.5, 3),
                new THREE.MeshPhongMaterial({ color: colorGreen, flatShading: true, shininess: 0}))
                // insidePart.position.z = -2;
                insidePart.position.y = 5.2;


                let apple1 = heart.clone(), apple2 = heart.clone();
                apple1.castShadow = apple1.receiveShadow = true;
                apple2.castShadow = apple2.receiveShadow = true;
                apple1.position.set(-1.5,2, 3.5);
                apple2.position.set(0.8,2.5, 3.5);
                heart.position.set(0.2,0.6, 3.7);
                tree = new THREE.Group();
                tree.add(treeTop,treeTrunk, apple1, apple2, heart, insidePart)

                tree.position.z =-7;
                
                scene.add(tree)

//board with instructions----------------------------------------------------

const boardGeometries = [];

            const colorboard = [];
                const boardbase = new THREE.CylinderGeometry(0.2,0.2,3,6);
                for (let i = 0; i < boardbase.attributes.position.count; i++)
                colorboard.push(colorBrown.r, colorBrown.g, colorBrown.b);
                boardbase.setAttribute(
                    'color',
                    new THREE.BufferAttribute(new Float32Array(colorboard), 3));
                boardGeometries.push(boardbase)

                const boardplack = new THREE.BoxGeometry(5,4,0.3);
                    boardplack.setAttribute(
                        'color',
                        new THREE.BufferAttribute(new Float32Array(colorboard), 3));
                boardGeometries.push(boardplack)

                const colorWhitePart = [];
                const WhitePart = new THREE.BoxGeometry(4.5,3.5,0.3);
                for (let i = 0; i < WhitePart.attributes.position.count; i++)
                colorWhitePart.push(colorWhite.r, colorWhite.g, colorWhite.b);
                    WhitePart.setAttribute(
                        'color',
                        new THREE.BufferAttribute(new Float32Array(colorWhitePart), 3));
                boardGeometries.push(WhitePart)
                

            boardbase.translate(-12,0,5);boardplack.translate(-12,3.5,5);WhitePart.translate(-12,3.5,5.1);
            
            const board = new THREE.Mesh(
                BufferGeometryUtils.mergeBufferGeometries(boardGeometries),
                new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0}))

                scene.add(board)

//backgroud--------------------------------------------------

            //rocks
            const bigRock = new THREE.Mesh(
                new THREE.TetrahedronGeometry(1,1),
                new THREE.MeshPhongMaterial({ color: colorRocks, flatShading: true,shininess: 0})
            );
            const smallRock = new THREE.Mesh(
                new THREE.TetrahedronGeometry(0.5,1),
                new THREE.MeshPhongMaterial({ color: colorRocks, flatShading: true,shininess: 0})
            );
            smallRock.rotateX(1.2,0,0)
            
            let smallRock1 = smallRock.clone();
            let bigRock1 = bigRock.clone();
            smallRock.position.x = 11;smallRock.position.z = -5; smallRock.position.y = smallRock1.position.y = -0.4;
            bigRock.position.x = 10;bigRock.position.z = -7; bigRock.position.y = bigRock.position.y = -0.3;
            smallRock1.position.x = -9; smallRock1.position.z = 5
            bigRock1.position.x = -12; bigRock1.position.z = -7

            let allRocks = new THREE.Group();
            allRocks.add(bigRock, smallRock, smallRock1, bigRock1);
            bigRock.castShadow = bigRock1.castShadow = smallRock.castShadow = smallRock1.castShadow = true;
            bigRock.receiveShadow = bigRock1.receiveShadow = smallRock.receiveShadow = smallRock1.receiveShadow = true;
            scene.add(allRocks);


//static bg elements------------
const staticGeometries = []
            const trunk1 = new THREE.BoxGeometry(3, 5, 3);

            const coloroftrunk = []
            for (let i = 0; i < trunk1.attributes.position.count; i++)
                coloroftrunk.push(colorBrown.r, colorBrown.g, colorBrown.b);
            // add color attribute to the trunk buffer geometry
            trunk1.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(coloroftrunk), 3));
            trunk1.translate(-6.5,1.5,-11)
            staticGeometries.push(trunk1);

            let trunk2 = trunk1.clone();
            let trunk3 = trunk1.clone();
            let trunk4 = trunk1.clone();
            
            trunk2.translate(23.8,0,-2.5);
            trunk3.translate(18.5,0,-8);
            trunk4.translate(9.5,0,-4.5);
            staticGeometries.push(trunk2, trunk3, trunk4);

            //boulders
                        // const rock = new THREE.TetrahedronGeometry(1,2);
            
                        // const colorsrock = []; // array of colors for each vertex of the rock geometry
                        // for (let i = 0; i < rock.attributes.position.count; i++)
                        //     colorsrock.push(colorRocks.r, colorRocks.g, colorRocks.b);
                        // // add color attribute to the rock buffer geometry
                        // rock.setAttribute(
                        //     'color',
                        //     new THREE.BufferAttribute(new Float32Array(colorsrock), 3));
                        // rock.translate(3,1,0);
                        // staticGeometries.push(rock);


            const staticGeometry = BufferGeometryUtils.mergeBufferGeometries(staticGeometries);
             let staticElements = new THREE.Mesh(
                staticGeometry,
                new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0})
            )
            staticElements.receiveShadow = true;
            staticElements.castShadow = true;
            staticElements.position.x = -5;
            staticElements.position.z = -4;
            scene.add(staticElements)

//bushes and leaves for trees(that move)
            const bgGeometries = []                
            const colorleaf = [];
                const upPart = new THREE.TorusGeometry(1.7,3,10,15);
                for (let i = 0; i < upPart.attributes.position.count; i++)
                colorleaf.push(colorGreen.r, colorGreen.g, colorGreen.b);
                // add color attribute to the upPart buffer geometry
                upPart.setAttribute(
                    'color',
                    new THREE.BufferAttribute(new Float32Array(colorleaf), 3));
                const downPart = new THREE.TorusGeometry(1.7,3,10,15);
                    downPart.setAttribute(
                        'color',
                        new THREE.BufferAttribute(new Float32Array(colorleaf), 3));

            upPart.rotateX(1.6,0,0); downPart.rotateX(1.6,0,0);
            upPart.translate(-6,7,-10); downPart.translate(-6,5.5,-10);
            let upPart2 = upPart.clone(); let upPart3 = upPart.clone();let upPart4 = upPart.clone();
            let downPart2 = downPart.clone(); let downPart3 = downPart.clone();let downPart4 = downPart.clone();
            
            upPart2.translate(22,0,-3); downPart2.translate(22,0,-3);
            upPart3.translate(17,0,-8); downPart3.translate(17,0,-8);
            upPart4.translate(9,0,-3);  downPart4.translate(9,0,-3);
            
            bgGeometries.push(upPart, downPart, upPart2, downPart2, upPart3, downPart3, upPart4, downPart4);
//bushes
            const bush = new THREE.SphereGeometry(1, 8, 5);
                    bush.setAttribute(
                        'color',
                        new THREE.BufferAttribute(new Float32Array(colorleaf), 3));
            bush.rotateZ(1.6,0,0);
            bush.translate(-9,-0.5,5);
            bgGeometries.push(bush);

            const bigBush = new THREE.SphereGeometry(1.7, 8, 5);
                    bigBush.setAttribute(
                        'color',
                        new THREE.BufferAttribute(new Float32Array(colorleaf), 3));
            bigBush.rotateX(1.6,0,0);
            bigBush.translate(-8,-0.5,3);
            bgGeometries.push(bigBush);

            const smallBush = new THREE.SphereGeometry(0.8, 6, 4);
                    smallBush.setAttribute(
                        'color',
                        new THREE.BufferAttribute(new Float32Array(colorleaf), 3));
            smallBush.rotateZ(1.2,0,0);
            smallBush.translate(-7,-0.5,5);
            bgGeometries.push(smallBush);

            let bigBush1 = bigBush.clone(), bigBush2 = bigBush.clone(), bigBush3 = bigBush.clone(), bigBush4 = bigBush.clone(), bigBush5 = bigBush.clone(),bigBush6 = bigBush.clone(),bigBush7 = bigBush.clone();
            bigBush1.translate(0,0,-10); bigBush2.translate(2,0,-20); bigBush3.translate(8,0,-17); bigBush4.translate(21,0,-18); bigBush5.translate(26.5,0,-18); bigBush6.translate(16,0,-21); bigBush7.translate(12,0,-19);
            bgGeometries.push(bigBush1, bigBush2, bigBush3, bigBush4, bigBush5, bigBush6, bigBush7);

            let bush1 = bush.clone(), bush2 = bush.clone(), bush3 = bush.clone(), bush4 = bush.clone();
            bush1.translate(5.5,0,-15); bush2.translate(18,0,-21); bush3.translate(14.5,0,-17); bush4.translate(23,0,-18);
            bgGeometries.push(bush1, bush2, bush3, bush4);

            let smallBush1 = smallBush.clone(), smallBush2 = smallBush.clone(), smallBush3 = smallBush.clone(), smallBush4 = smallBush.clone();
            smallBush1.translate(11,0,-16); smallBush2.translate(24,0,-16); smallBush3.translate(1,0,-13); smallBush4.translate(23,0,-18);
            bgGeometries.push(smallBush1, smallBush2, smallBush3, smallBush4);
            bush.translate(0,0,4); bigBush.translate(0,0,4); smallBush.translate(0,0,4);


            let bigBushes1 = bigBush.clone(), bigBushes2 = bigBush.clone();
            bigBushes1.translate(26,0,1); bigBushes2.translate(26,0,-12);
            bgGeometries.push(bigBushes1, bigBushes2);

            let Bushes1 = bush.clone(), Bushes2 = bush.clone();
            Bushes1.translate(28,0,-3); Bushes2.translate(0,0,-11);
            bgGeometries.push(Bushes1, Bushes2);

            let smallBushes1 = smallBush.clone(), smallBushes2 = smallBush.clone(), smallBushes3 = smallBush.clone();
            smallBushes1.translate(23,0,0); smallBushes2.translate(5,0,-1); smallBushes3.translate(22,0,-3);
            bgGeometries.push(smallBushes1, smallBushes2, smallBushes3);

//----------------------------------------------------------------

            const bgGeometry = BufferGeometryUtils.mergeBufferGeometries(bgGeometries);
             bg = new THREE.Mesh(
                bgGeometry,
                new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0})
            )
            bg.receiveShadow = true;
            bg.castShadow = true;
            bg.position.x = -5;
            bg.position.z = -4;
            bg.scale.x = 1.1;
            bg.scale.z = 1.1;
            bg.scale.y = 1.1;
            scene.add(bg)


// black cat

            const catGeometries = []

            const body = new THREE.BoxGeometry(1.5, 1, 1);
            const colorsBody = []; // array of colors for each vertex of the leaves geometry
            // Do this ONLY ONCE, since ALL 3 level catGeometries have the SAME number of vertices
            for (let i = 0; i < body.attributes.position.count; i++)
                colorsBody.push(colorGray.r, colorGray.g, colorGray.b);
    //body
            body.translate(0, 0.2, 0)
            // add color attribute to the body buffer geometry
            body.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBody), 3));
            catGeometries.push(body);

            const head = new THREE.BoxGeometry(2.25, 1.7, 1.6);
            head.translate(0, 1.55, 0)
            head.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBody), 3));
            catGeometries.push(head);

            const snout = new THREE.BoxGeometry(2, 0.5, 0.3);
            snout.translate(0, 0.95, 0.9)
            snout.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBody), 3));
            catGeometries.push(snout);


//forehead
            const forehead = new THREE.BoxGeometry(0.84, 0.5, 1.62);
            const colorsWhite = [];
            for (let i = 0; i < forehead.attributes.position.count; i++)
                colorsWhite.push(colorWhite.r, colorWhite.g, colorWhite.b);
            forehead.translate(0, 2.16,0);
            forehead.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsWhite), 3));
            catGeometries.push(forehead);

//--> cheeks
            const cheekl = new THREE.BoxGeometry(0.4, 0.2, 0.1);
            const colorsPink = [];
            for (let i = 0; i < cheekl.attributes.position.count; i++)
                colorsPink.push(colorPink.r, colorPink.g, colorPink.b);
            cheekl.translate(-0.93, 0.81, 1.1)
            cheekl.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsPink), 3));
            catGeometries.push(cheekl);

            const cheekr = new THREE.BoxGeometry(0.4, 0.2, 0.1);
            cheekr.translate(0.93, 0.81, 1.1)
            cheekr.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsPink), 3));
            catGeometries.push(cheekr);

//colar
    const colar = new THREE.BoxGeometry(1.7, 0.5, 1.2);
            const colorsPurple = [];
            for (let i = 0; i < colar.attributes.position.count; i++)
                colorsPurple.push(colorPurple.r, colorPurple.g, colorPurple.b);
            colar.translate(0, 0.7, 0)
            colar.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsPurple), 3));
            catGeometries.push(colar);
                    
            //whiskers
            const whiskerl = new THREE.CylinderGeometry(0.06, 0.06, 0.5,4,1);
            const colorsBlack = [];
            for (let i = 0; i < whiskerl.attributes.position.count; i++)
                colorsBlack.push(colorBlack.r, colorBlack.g, colorBlack.b);
            whiskerl.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBlack), 3));
            whiskerl.translate(0.9, 1.2, 0.7);
            whiskerl.rotateZ(1.6,0,0);
            const whiskerl2 = whiskerl.clone()
            whiskerl2.translate(0,0.3,0)
            catGeometries.push(whiskerl,whiskerl2);

            const whiskerr = new THREE.CylinderGeometry(0.06, 0.06, 0.5,4,1);
            whiskerr.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBlack), 3));
            whiskerr.translate(0.9, -1.2, 0.7);
            whiskerr.rotateZ(1.6,0,0);
            const whiskerr2 = whiskerr.clone()
            whiskerr2.translate(0,0.3,0)
            catGeometries.push(whiskerr,whiskerr2);

//mesh/adding cat to scene           
            const blackCatGeometry = BufferGeometryUtils.mergeBufferGeometries(catGeometries);
            blackCat = new THREE.Mesh(
                blackCatGeometry,new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0})
            )
            blackCat.castShadow = true;
            blackCat.receiveShadow = true;

// eyes and nose and bell(shiny parts)
const shinyGeometries =[];
    const eyel = new THREE.SphereGeometry(0.25, 4,10);
    eyel.rotateX(1.6,0,0);
    eyel.rotateZ(0.8,0,0);
    eyel.translate(-0.7, 1.35, 0.7)
    const colorshinyBlack = [];
    for (let i = 0; i < eyel.attributes.position.count; i++)
        colorshinyBlack.push(colorBlack.r, colorBlack.g, colorBlack.b);
            eyel.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorshinyBlack), 3));
            shinyGeometries.push(eyel);

            const eyer = new THREE.SphereGeometry(0.25, 4,10);
            eyer.rotateX(1.6,0,0);
            eyer.rotateZ(0.8,0,0);
            eyer.translate(0.7, 1.35, 0.7)
            eyer.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorshinyBlack), 3));
            shinyGeometries.push(eyer);

        //lil nose
            const nose = new THREE.BoxGeometry(0.3, 0.1, 0.3);
            nose.translate(0, 1.1, 1)
            nose.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorshinyBlack), 3));
            shinyGeometries.push(nose);

            const shinyGeometry = BufferGeometryUtils.mergeBufferGeometries(shinyGeometries);
            features = new THREE.Mesh(
                shinyGeometry,new THREE.MeshPhysicalMaterial({ vertexColors: true, metalness:0.2, roughness:0.1, flatShading:true})
            )
            features.castShadow = true;
            features.receiveShadow = true;

// parts that move-----------------------------------------------------------------------------------------------------------------------

    // legs
    legl = new THREE.Mesh(
    new THREE.BoxGeometry(0.5, 0.7, 0.6),
    new THREE.MeshPhongMaterial({ color: colorWhite, flatShading: true, shininess: 0}));
    legl.position.x = -0.49;
    legl.position.y = -0.4;
    legl.receiveShadow = legl.castShadow = true;

    legr = new THREE.Mesh(
    new THREE.BoxGeometry(0.5, 0.7, 0.6),
    new THREE.MeshPhongMaterial({ color: colorWhite, flatShading: true, shininess: 0}));
    legr.position.x = 0.49;
    legr.position.y = -0.4;
    legr.receiveShadow = legr.castShadow = true;

//arms
            shoulderl = new THREE.Object3D();
            shoulderl.position.set(-0.7, 0.35, 0);
            shoulderl.rotation.z = THREE.Math.degToRad(20);
            scene.add(shoulderl);
            
  armUpl = new THREE.Mesh(
    new THREE.BoxGeometry(0.5, 0.5, 0.5),
    new THREE.MeshPhongMaterial({ color: colorGray, flatShading: true, shininess: 0}));
    armUpl.position.set(-0.25, 0, 0);
    // armUpl.rotateZ(0.3,0.3,1);
    shoulderl.add(armUpl)
    armUpl.receiveShadow = armUpl.castShadow = true;


    shoulderr = new THREE.Object3D();
            shoulderr.position.set(0.7, 0.35, 0);
            shoulderr.rotation.z = THREE.Math.degToRad(-20);
            scene.add(shoulderr);
            
    armUpr = new THREE.Mesh(
    new THREE.BoxGeometry(0.5, 0.5, 0.5),
    new THREE.MeshPhongMaterial({ color: colorGray, flatShading: true, shininess: 0}));
    armUpr.position.set(0.25, 0, 0);
    shoulderr.add(armUpr)
    armUpr.receiveShadow = armUpr.castShadow = true;
//forearms

            elbowl = new THREE.Object3D();
            elbowl.position.set(-0.25, 0, 0);
            armUpl.add(elbowl);

    forearml = new THREE.Mesh(
    new THREE.BoxGeometry(0.3, 0.5, 0.5),
    new THREE.MeshPhongMaterial({ color: colorWhite, flatShading: true, shininess: 0}));
    forearml.position.set(-0.15,0,0);
    elbowl.add(forearml);
    forearml.receiveShadow = forearml.castShadow = true;


            elbowr = new THREE.Object3D();
            elbowr.position.set(0.25, 0, 0);
            armUpr.add(elbowr);

    forearmr = new THREE.Mesh(
    new THREE.BoxGeometry(0.3, 0.5, 0.5),
    new THREE.MeshPhongMaterial({ color: colorWhite, flatShading: true, shininess: 0}));
    forearmr.position.set(0.15,0,0);
    elbowr.add(forearmr);
    forearmr.receiveShadow = forearmr.castShadow = true;

//  ears(rectangular)
            let leftEarG = [];
            let rightEarG = [];

            const outEarl = new THREE.BoxGeometry(0.7,0.4,0.7);
            outEarl.translate(-0.79, 2.6, 0.47)
            const colorGrayEar = [];
            for (let i = 0; i < outEarl.attributes.position.count; i++)
                colorGrayEar.push(colorGray.r, colorGray.g, colorGray.b);
            outEarl.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorGrayEar), 3));
            leftEarG.push(outEarl);

            const outEarr = new THREE.BoxGeometry(0.7,0.4,0.7);
            outEarr.translate(0.79, 2.6, 0.47)
            outEarr.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorGrayEar), 3));
            rightEarG.push(outEarr);

            const inEarl = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            inEarl.translate(-0.95, 2.3, 0.621)
            const colorPinkEar = [];
            for (let i = 0; i < inEarl.attributes.position.count; i++)
                colorPinkEar.push(colorPink.r, colorPink.g, colorPink.b);
            inEarl.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorPinkEar), 3));
            leftEarG.push(inEarl);

            const inEarr = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            inEarr.translate(0.95, 2.3, 0.621)
            inEarr.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorPinkEar), 3));
            rightEarG.push(inEarr);


            earl = new THREE.Mesh(
                BufferGeometryUtils.mergeBufferGeometries(leftEarG)
                ,new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0})
            )
            earl.castShadow = true;
            earl.receiveShadow = true;

            earr = new THREE.Mesh(
                BufferGeometryUtils.mergeBufferGeometries(rightEarG)
                ,new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0})
            )
            earr.castShadow = true;
            earr.receiveShadow = true;

//tail
            tail = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05,0.4,1,6),
                new THREE.MeshPhongMaterial({ color: colorGray, flatShading: true, shininess: 0})
            );
            tail.rotation.x = THREE.Math.degToRad(-70) 
            tail.position. y= 0.3;
            tail.position.z = -0.7;
            tail.castShadow = tail.receiveShadow = true;

// bell
            bell = new THREE.Mesh(
                new THREE.SphereGeometry(0.3,8,5),
                new THREE.MeshStandardMaterial({ color: colorYellow, flatShading: true, metalness:0.5, roughness:0.2})
            );
            bell.position.y = 0.3;
            bell.position.z = 0.7;
            bell.castShadow = true;
            bell.receiveShadow = true;

//group everything together
            blackKittybody = new THREE.Group();
            blackKittybody.add(blackCat, shoulderl, shoulderr, features, legl, legr, earl, earr);
            blackKitty = new THREE.Group();
            blackKitty.add(blackKittybody, bell,tail);
            scene.add(blackKitty);


//animations
            // SAVE initial vertices coordinates and settings for their circular motion
            for (let i = 0; i < bg.geometry.attributes.position.count; i++) {
                verts.push({
                    x: bg.geometry.attributes.position.getX(i),
                    y: bg.geometry.attributes.position.getY(i),

                    ang: Math.random() * Math.PI * 2,   // initial angle
                    amp: -0.1 + Math.random() * 0.2,        // radius
                    speed: 0.02 + Math.random() * 0.02  // angular velocity
                });
            }

            for (let i = 0; i < treeTop.geometry.attributes.position.count; i++) {
                vertsTree.push({
                    x: treeTop.geometry.attributes.position.getX(i),
                    y: treeTop.geometry.attributes.position.getY(i),

                    ang: Math.random() * Math.PI * 2,   // initial angle
                    amp: -0.1 + Math.random() * 0.2,        // radius
                    speed: 0.02 + Math.random() * 0.02  // angular velocity
                });
            }

//------------------------

function handleKeyDown(e) {
    e.preventDefault();
    keyPressed = true
    if(!started){
        if(e.key == "Enter"){
            started = true;
            camera.position.set(1,3,13);
            camera.rotation.x = 0;
            indicator.position.y = 0;
            indicator.rotation.y = 0;
        }else if(e.key == "1"){
            heart.position.x = -4;
        }else if(e.key == "2"){
            heart.position.x = 0;
        }else if(e.key == "3"){
            heart.position.x = 4;
        }

    }
    else if(started){
        if (e.key == "ArrowRight" && blackKitty.position.x < 14
        // && !(
        //     blackKitty.position.x >= tree.position.x - 2
        //     && blackKitty.position.z <= tree.position.z + 2 && blackKitty.position.z >= tree.position.z - 2
        //    )
        ) {
            rightKey = true;
            Actions(e);
        }else if (e.key == "ArrowLeft" && blackKitty.position.x > -14
        // && !(
        //     blackKitty.position.x <= tree.position.x + 2
        //     && blackKitty.position.z <= tree.position.z + 2 && blackKitty.position.z >= tree.position.z - 2
        //    )
        ) {
            leftKey = true;
            Actions(e);
        }else if (e.key == "ArrowUp" && blackKitty.position.z > -20
        // && !(
        //     blackKitty.position.x <= tree.position.x + 2 && blackKitty.position.x >= tree.position.x - 2
        //     && blackKitty.position.z <= tree.position.z + 2
        //    )
        ) {
            upKey = true;
            Actions(e);
        }else if (e.key == "ArrowDown" && blackKitty.position.z < 5
        // && !(
        //     blackKitty.position.x <= tree.position.x + 2 && blackKitty.position.x >= tree.position.x - 2
        //     && blackKitty.position.z >= tree.position.z - 2
        //    )
        ) {
            downKey = true;
            Actions(e);
        }else if (e.key == "s" 
           && (
            blackKitty.position.x <= tree.position.x + 3.5 && blackKitty.position.x >= tree.position.x - 3.5
            && blackKitty.position.z <= tree.position.z + 3.5 && blackKitty.position.z >= tree.position.z - 3.5
           )
        ) {

            toShake = true;
            // shoulderl.rotation.y = THREE.Math.degToRad(60);
            // shoulderr.rotation.y = THREE.Math.degToRad(-60);
            // elbowl.rotation.z = -THREE.Math.degToRad(20);
            // elbowr.rotation.z = THREE.Math.degToRad(20);
            // earl.rotation.x += 6*(Math.sin(Date.now() * 0.015) * Math.PI/2 * 0.001);
            // earr.rotation.x += 6*(Math.sin(Date.now() * 0.015) * Math.PI/2 * 0.001);
            // blackKittybody.position.z += (Math.sin(Date.now() * 0.4) * Math.PI/2 * 0.01)*3
            // tail.position.z += (Math.sin(Date.now() * 0.4) * Math.PI/2 * 0.01)*3;
            // bell.position.z += (Math.sin(Date.now() * 0.4) * Math.PI/2 * 0.01)*3;
            // bell.rotation.x -= -2*(Math.sin(Date.now() * 0.02) * Math.PI/2 * 0.06);
            // tail.rotation.x = THREE.Math.degToRad(-90);

            // treeTop.rotation.z = 20*(Math.sin(Date.now() * 0.015) * Math.PI/2 * 0.001);
        }
    }
}

function handleKeyUp(e) {
    if (e.key == 'ArrowRight'){
		rightKey = false;
	}
	else if (e.key == 'ArrowLeft'){
		leftKey = false;
	}
	else if (e.key == 'ArrowUp'){
		upKey = false;
	}
	else if (e.key == 'ArrowDown'){
		downKey = false;
	}
    legl.rotation.x = legr.rotation.x = bell.rotation.x = 0;
    shoulderl.rotation.z = THREE.Math.degToRad(20);
    shoulderr.rotation.z = THREE.Math.degToRad(-20);
    earl.rotation.z = earr.rotation.z = 0;
    earl.rotation.x = earr.rotation.x = 0;
    blackKittybody.position.y = 0;

    tail.position.z = -0.7;
    bell.position.z = 0.7;
    blackKittybody.position.z = 0;
    tail.rotation.x = THREE.Math.degToRad(-70);
    earl.rotation.x = earr.rotation.x = 0;
    shoulderl.rotation.y = shoulderr.rotation.y = 0;
    elbowl.rotation.z = elbowr.rotation.z = 0;

    treeTop.rotation.z = 0;
}

// function for walking
function Actions(e){
    e.preventDefault();
    if (rightKey && blackKitty.position.x < 14) {
        blackKitty.position.x += 0.22;
        blackKitty.rotation.y = 1.6;
    }else if (leftKey && blackKitty.position.x > -14) {
        blackKitty.position.x -= 0.22;
        blackKitty.rotation.y = -1.6;
    }else if (upKey && blackKitty.position.z > -20) {
        blackKitty.position.z -= 0.22;
        blackKitty.rotation.y = 3.2;
    }else if (downKey && blackKitty.position.z < 5) {
        blackKitty.position.z += 0.22;
        blackKitty.rotation.y = 0;
    }
    blackKittybody.position.y = 0
    blackKittybody.position.y += (Math.sin(Date.now() * 0.4) * Math.PI/2 * 0.01)*6;
    shoulderl.rotation.z += -2*(Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.03);
    shoulderr.rotation.z -= -2*(Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.03);
    bell.rotation.x -= -(Math.sin(Date.now() * 0.02) * Math.PI/2 * 0.06);
    earl.rotation.z -= 3*(Math.sin(Date.now() * 0.012) * Math.PI/2 * 0.001);
    earr.rotation.z += 3*(Math.sin(Date.now() * 0.012) * Math.PI/2 * 0.001);
    //leg movements1
    legl.rotation.x += Math.sin(Date.now() * 0.014) * Math.PI/2 * 0.12;
    legr.rotation.x -= Math.sin(Date.now() * 0.014) * Math.PI/2 * 0.12;
}

document.onkeydown = handleKeyDown;
document.onkeyup = handleKeyUp;

// ----------------------------           
                renderer.setAnimationLoop(render);
            }

            function render(){

            //before starting
            if(!started){
                // camera.position.y = 6
                // camera.position.x += 2*(Math.sin(Date.now() * 0.001) * Math.PI/2 * 0.02);
                // camera.lookAt(scene.position);
                indicator.rotation.y += 0.02;
                indicator.position.y += Math.sin(Date.now() * 0.0025) * Math.PI/2 * 0.008;
            }

            
            //movimentation of indicator
            // heart.scale.x = heart.scale.z = heart.scale.y +=  0.02
            // heart.position.y -= 0.06;
            // if(heart.scale.x >= 2){
            //     heart.scale.x = heart.scale.z = heart.scale.y =  1
            //     heart.position.y = 0
            // }

            if(toShake){
                shoulderl.rotation.y = THREE.Math.degToRad(60);
                shoulderr.rotation.y = THREE.Math.degToRad(-60);
                elbowl.rotation.z = -THREE.Math.degToRad(20);
                elbowr.rotation.z = THREE.Math.degToRad(20);
                earl.rotation.x += 6*(Math.sin(Date.now() * 0.015) * Math.PI/2 * 0.001);
                earr.rotation.x += 6*(Math.sin(Date.now() * 0.015) * Math.PI/2 * 0.001);
                blackKittybody.position.z += (Math.sin(Date.now() * 0.4) * Math.PI/2 * 0.01)*3
                tail.position.z += (Math.sin(Date.now() * 0.4) * Math.PI/2 * 0.01)*3;
                bell.position.z += (Math.sin(Date.now() * 0.4) * Math.PI/2 * 0.01)*3;
                bell.rotation.x -= -2*(Math.sin(Date.now() * 0.02) * Math.PI/2 * 0.06);
                tail.rotation.x = THREE.Math.degToRad(-90);
                treeTop.rotation.z = 20*(Math.sin(Date.now() * 0.015) * Math.PI/2 * 0.001);
                
                setInterval(function() {

                    shoulderl.rotation.z = THREE.Math.degToRad(20);
                    shoulderr.rotation.z = THREE.Math.degToRad(-20);
                    earl.rotation.z = earr.rotation.z = 0;

                    tail.position.z = -0.7;
                    bell.position.z = 0.7;
                    blackKittybody.position.z = 0;
                    tail.rotation.x = THREE.Math.degToRad(-70);
                    earl.rotation.x = earr.rotation.x = 0;
                    shoulderl.rotation.y = shoulderr.rotation.y = 0;
                    elbowl.rotation.z = elbowr.rotation.z = 0;

                    treeTop.rotation.z = 0;

                    toShake = false;
                    toFall = true;
                },1000)
            }

            if(toFall){
                heart.rotation.x += THREE.Math.degToRad(5)
                if(heart.rotation.x >= THREE.Math.degToRad(90)){
                    heart.rotation.x = THREE.Math.degToRad(90);
                }
                heart.rotation.z += THREE.Math.degToRad(5)
                if(heart.rotation.z >= THREE.Math.degToRad(40)){
                    heart.rotation.z = THREE.Math.degToRad(40);
                }
                heart.position.y -= 0.1;
                if(heart.position.y <= -0.35){
                    heart.position.y = -0.35;
                }
                toFall = false;
            }

            //default movimentation
            
                blackKittybody.position.y += Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.002;
                tail.rotation.x -= Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.01;
                shoulderl.rotation.z += Math.sin(Date.now() * 0.009) * Math.PI/2 * 0.005;
                shoulderr.rotation.z -= Math.sin(Date.now() * 0.009) * Math.PI/2 * 0.005;
                bell.position.y += Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.0025;
                bell.position.z -= Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.0025;
                bell.rotation.x += Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.01;
                earl.rotation.z -= Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.0015;
                earr.rotation.z += Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.0015;
                

            renderer.render(scene, camera);
            // controls.update();


             for (let i = 0; i < bg.geometry.attributes.position.count; i++) {
                let vprops = verts[i];
                let currentXposition = vprops.x + Math.cos(vprops.ang) * vprops.amp;
                let currentYposition = vprops.y + Math.sin(vprops.ang) * vprops.amp;
                vprops.ang += vprops.speed +0.02;
                bg.geometry.attributes.position.setXY(i, currentXposition, currentYposition);
            }
            bg.geometry.attributes.position.needsUpdate = true;

            for (let i = 0; i < treeTop.geometry.attributes.position.count; i++) {
                let vpropsTree = vertsTree[i];
                let currentXpositionTree = vpropsTree.x + Math.cos(vpropsTree.ang) * vpropsTree.amp;
                let currentYpositionTree = vpropsTree.y + Math.sin(vpropsTree.ang) * vpropsTree.amp;
                vpropsTree.ang += vpropsTree.speed - 0.05;
                treeTop.geometry.attributes.position.setXY(i, currentXpositionTree, currentYpositionTree);
            }
            treeTop.geometry.attributes.position.needsUpdate = true;

        }
    </script>
</body>
</html>