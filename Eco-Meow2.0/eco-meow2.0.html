<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Eco-Meow 2.0</title>

    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import { OrbitControls } from "./libs/OrbitControls.js";
      import * as THREE from "./libs/three.module.js";
      import * as BufferGeometryUtils from "./libs/BufferGeometryUtils.js";

      // const geometry = new BufferGeometry();
      let controls;
      let camera, scene, renderer;

      let keyPressed,
        rightKey,
        leftKey,
        upKey,
        downKey,
        toShake,
        toFall,
        toBend,
        toGrab,
        toEat,
        oEarL,
        oEarR;
      let started = false;

      let heart, tree, treeTop, indicator, spot, bbHelper, arm1;

      let n=0;
      let waterTree=false;

      let shoulderl, elbowl, shoulderr, elbowr;
      let legl, legr, armUpl, armUpr, forearml, forearmr, earl, earr, tail;
      let features, bell, blackCat, blackKittybody, armsl, armsr;
      let whiteKitty, orangeKitty, blackKitty;
      let whiteKittybody, whiteCat, wLegL, wLegR, wShiny, wShoulderL, wShoulderR, wArmDownR, wElbowR, pointBell, wBell;

      let bg;
      let verts = [];
      let vertsTree = [];
      let obstcls = [];
      let num = 2;
      let selectCat = orangeKitty;
      let arrowHelp;
      let heartO, heartB, heartW;

      // let initialRot =[]

      window.onload = function init() {
        scene = new THREE.Scene();

        const aspect = window.innerWidth / window.innerHeight;
        camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 50); // perspective camera

        camera.position.z = 15;
        camera.position.x = 0;
        camera.position.y = 8;

        camera.lookAt(scene.position); //point the camera to the center of the scene

        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight); // set output canvas and viewport size

        controls = new OrbitControls(camera, renderer.domElement);

        // configure renderer clear color
        renderer.setClearColor("#9BD4C3");
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // add the output of the renderer to an HTML element (adds a Canvas element to the body)
        document.body.appendChild(renderer.domElement);

        // const axeHelper = new THREE.AxesHelper(5);
        // scene.add(axeHelper);

        //----------------------------------------------------------------
        // lights
        // let light = new THREE.AmbientLight(0xffffff, 0.7);
        let light = new THREE.AmbientLight(0xeae178, 0.7);
        scene.add(light);

        let light2 = new THREE.PointLight(0xeae178, 0.7, 100);
        light2.position.set(-15, 8, 6);
        light2.castShadow = true;
        light2.shadow.camera;
        scene.add(light2);

        let light3 = new THREE.PointLight(0xffffff, 0.5, 100);
        light3.position.set(5, 8, 7);
        scene.add(light3);
        // light helper
        let pointLightHelper = new THREE.PointLightHelper(light2, 0.4);
        let pointLightHelper1 = new THREE.PointLightHelper(light3, 0.4);
        // pointLightHelper.name = "helper";
        // scene.add(pointLightHelper);
        // scene.add(pointLightHelper1);

        // ----------
        // colors
        const colorGreenShade = new THREE.MeshPhongMaterial({
          color: 0xa4c263,
          flatShading: true,
          shininess: 0,
        });
        const colorGreen = new THREE.Color(0xa4c263);
        const colorBrown = new THREE.Color(0x8c7369);
        const colorRocks = new THREE.Color(0x9da89a);
        const colorGray = new THREE.Color(0x494949);
        const colorBlack = new THREE.Color(0x000000);
        const colorWhite = new THREE.Color(0xf7f7f2);
        const colorPink = new THREE.Color(0xe8b5ac);
        const colorPurple = new THREE.Color(0x8f76d4);
        const colorYellow = new THREE.Color(0xeae178);
        const colorRed = new THREE.Color(0xbd757e);
        const colorOrange = new THREE.Color(0xeaa945);
        const colorBlue = new THREE.Color(0x00ffff);
        const colorBege = new THREE.Color(0xf3f2c0);
        const colorTail = new THREE.Color(0xF3F2C0);
        const colorBlush = new THREE.Color(0xefc5de);
        const colorPinkw = new THREE.Color(0xE8B5AC);
        const colorTongue = new THREE.Color(0xEBA598);
        const colorLightPurple = new THREE.Color(0xdaccff);
        const colorDarkPurple = new THREE.Color(0x766daa);
        const colorDarkGreen = new THREE.Color(0x97BB8E);

        //pointer
        let ind = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, 0.5),
          new THREE.MeshPhongMaterial({
            color: colorDarkGreen,
            flatShading: true,
            shininess: 0,
          })
        );
        ind.position.y = 2.7;

        let ind2 = new THREE.Mesh(
          new THREE.CylinderGeometry(0.15, 0.1, 0.5),
          new THREE.MeshPhongMaterial({
            color: colorDarkGreen,
            flatShading: true,
            shininess: 0,
          })
        );
        ind2.position.x = -0.2;
        ind2.position.y = 3;
        ind2.rotation.z = 1;

        let ind3 = ind2.clone();
        ind3.position.x = 0.2;
        ind3.rotation.z = -1;

        indicator = new THREE.Group();
        indicator.add(ind, ind2, ind3);
        indicator.position.y = 1;
        indicator.position.z = 3;
        scene.add(indicator);

        //-------------
        //arrow that shows up to help player

        arrowHelp = new THREE.Mesh(
          new THREE.ConeGeometry(1,1.5,8),
          new THREE.MeshPhongMaterial({
            color: colorPurple,
            transparent: true,
            opacity: 0.6,
            flatShading: true,
            shininess: 0,
          })
        );

        arrowHelp.position.set(0,2,-6);
        arrowHelp.rotation.x = THREE.Math.degToRad(180);
        arrowHelp.castShadow = true;

        //-------------


        //shape of the apples
        const heartl = new THREE.Mesh(
          new THREE.SphereGeometry(0.5, 6, 6),
          new THREE.MeshStandardMaterial({
            color: colorRed,
            flatShading: true,
            roughness: 0.4,
          })
        );
        heartl.rotateZ(0.6, 0, 0);
        heartl.position.x = -0.35;
        heartl.position.y = 3.8;
        const heartr = heartl.clone();
        heartr.position.x = 0.35;
        heartr.rotateZ(-1.2, 0, 0);
        const heartbase = heartl.clone();
        heartbase.position.y = 3.45;
        heartbase.position.x = 0;
        heartbase.rotateZ(-0.6, 0, 0);

        const midl = new THREE.Mesh(
          new THREE.CylinderGeometry(0.499, 0.5, 0.5, 6),
          new THREE.MeshStandardMaterial({
            color: colorRed,
            flatShading: true,
            roughness: 0.4,
          })
        );
        midl.rotateZ(0.8, 0, 0);
        midl.rotateY(1.6, 0, 0);
        midl.position.x = -0.2;
        midl.position.y = 3.65;
        const midr = midl.clone();
        midr.rotateZ(-3.2, 0, 0);
        midr.rotateX(-1.6, 0, 0);
        midr.position.x = 0.2;

        heartl.castShadow = heartl.receiveShadow = true;
        heartr.castShadow = heartr.receiveShadow = true;
        midl.castShadow = midl.receiveShadow = true;
        midr.castShadow = midr.receiveShadow = true;

        let leaf = indicator.clone();
        leaf.scale.set(0.8, 0.8, 0.8);
        leaf.position.z = 0;
        leaf.position.y = 2;
        heart = new THREE.Group();
        heart.add(heartl, heartr, heartbase, midl, midr, leaf);
        heart.castShadow = heart.receiveShadow = true;

        //hearts for the end of the game------
        let newheartl = heartl.clone(), newheartr = heartr.clone(), newheartbase = heartbase.clone(), newmidl = midl.clone(), newmidr = midr.clone()
        heartO = new THREE.Group();
        heartO.add(newheartl,newheartr,newheartbase,newmidl, newmidr);
        heartO.position.y = 3
        heartO.scale.set(0.5,0.5,0.5)

        heartB = heartO.clone();
        heartW = heartO.clone();
        

        // background

        // ground
        let geometry = new THREE.BoxGeometry(35, 1.5, 35);
        let plane = new THREE.Mesh(geometry, colorGreenShade);
        plane.position.y = -1.5;
        plane.position.z = -9;
        plane.receiveShadow = true;
        scene.add(plane);

        //spot to plant the tree
        let texture = new THREE.TextureLoader().load("./libs/spot.png");
        let material = new THREE.MeshPhongMaterial({
          map: texture,
          shininess: 0,
        });

        spot = new THREE.Mesh(new THREE.PlaneGeometry(9, 9), material);
        spot.rotation.x = THREE.Math.degToRad(-90);
        spot.position.set(0, -0.7, -6);
        spot.receiveShadow = true;
        scene.add(spot);

        // tree thats gonna get planted
        const treeGeometries = [];
        const colorTree = [];
        const treeupPart = new THREE.TorusGeometry(2.3, 1.5, 10, 15);
        for (let i = 0; i < treeupPart.attributes.position.count; i++)
          colorTree.push(colorGreen.r, colorGreen.g, colorGreen.b);
        // add color attribute to the upPart buffer geometry
        treeupPart.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorTree), 3)
        );
        const treedownPart = new THREE.TorusGeometry(2.3, 1.5, 10, 15);
        treedownPart.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorTree), 3)
        );

        treeupPart.rotateX(1.6, 0, 0);
        treedownPart.rotateX(1.6, 0, 0);
        treedownPart.translate(0, 4.5, 0);
        treeupPart.translate(0, 6, 0);
        treeGeometries.push(treeupPart, treedownPart);

        treeTop = new THREE.Mesh(
          BufferGeometryUtils.mergeBufferGeometries(treeGeometries),
          new THREE.MeshPhongMaterial({
            vertexColors: true,
            flatShading: true,
            shininess: 0,
          })
        );

        const treeTrunk = new THREE.Mesh(
          new THREE.BoxGeometry(2.5, 5.5, 2.5),
          new THREE.MeshPhongMaterial({
            color: colorBrown,
            flatShading: true,
            shininess: 0,
          })
        );

        treeTrunk.position.y = 0.6;

        treeTop.receiveShadow = treeTop.castShadow = true;
        treeTrunk.castShadow = treeTrunk.receiveShadow = true;

        const insidePart = new THREE.Mesh(
          new THREE.BoxGeometry(6, 3.5, 3),
          new THREE.MeshPhongMaterial({
            color: colorGreen,
            flatShading: true,
            shininess: 0,
          })
        );
        // insidePart.position.z = -2;
        insidePart.position.y = 5.2;

        let apple1 = heart.clone(),
          apple2 = heart.clone();
        apple1.castShadow = apple1.receiveShadow = true;
        apple2.castShadow = apple2.receiveShadow = true;
        apple1.position.set(-1.5, 2, 3.5);
        apple2.position.set(0.8, 2.5, 3.5);
        
        tree = new THREE.Group();
        tree.add(treeTop, treeTrunk, apple1, apple2, insidePart);
        
        // let axesheart = new THREE.AxesHelper(4);
        // heart.add(axesheart);
        heart.position.set(0.2, 0.4, -3.2);
        heart.scale.set(1 / 3, 1 / 3, 1 / 3);
        

        tree.position.z = -7;
        tree.scale.set(1 / 3, 1 / 3, 1 / 3);

        // scene.add(tree);

        //board with instructions----------------------------------------------------

        const boardbase = new THREE.Mesh(
           new THREE.CylinderGeometry(0.2, 0.2, 5, 6),
           new THREE.MeshPhongMaterial({
            color: colorBrown,
            flatShading: true,
            shininess: 0,
          })
        );

        const boardplack = new THREE.Mesh(
          new THREE.BoxGeometry(5, 4, 0.3),
          new THREE.MeshPhongMaterial({
            color: colorBrown,
            flatShading: true,
            shininess: 0,
          }))

        boardplack.rotateX = 1.6

        let texturei = new THREE.TextureLoader().load("./libs/instrucoes.png");
        let materiali = new THREE.MeshPhongMaterial({
          map: texturei,
          shininess: 0,
        });

        let info = new THREE.Mesh(
          new THREE.BoxGeometry(4.5, 3.5, 0.3),
          materiali
        );
        
        boardbase.position.set(-12, 1, 5);
        boardplack.position.set(-12, 3.5, 5.09);
        info.position.y = 3.5;
        info.position.z = 5.1;
        info.position.x = -12;

        let board = new THREE.Group();
        board.add(boardbase, boardplack, info);
          
          info.castShadow =
          info.receiveShadow =
          board.castShadow =
          board.receiveShadow =
          true;

          info.rotation.x = boardplack.rotation.x = THREE.Math.degToRad(-30)
          scene.add(board)

        let infoPos = info.position.clone();
        obstcls.push(infoPos);

        //backgroud--------------------------------------------------

        //static bg elements------------
        //rocks
        const bigRock = new THREE.Mesh(
          new THREE.TetrahedronGeometry(1, 1),
          new THREE.MeshPhongMaterial({
            color: colorRocks,
            flatShading: true,
            shininess: 0,
          })
        );
        const smallRock = new THREE.Mesh(
          new THREE.TetrahedronGeometry(0.5, 1),
          new THREE.MeshPhongMaterial({
            color: colorRocks,
            flatShading: true,
            shininess: 0,
          })
        );
        smallRock.rotateX(1.2, 0, 0);

        let smallRock1 = smallRock.clone();
        let bigRock1 = bigRock.clone();
        smallRock.position.x = 11;
        smallRock.position.z = -5;
        smallRock.position.y = smallRock1.position.y = -0.4;
        bigRock.position.x = 10;
        bigRock.position.z = -7;
        bigRock.position.y = bigRock.position.y = -0.3;
        smallRock1.position.x = -9;
        smallRock1.position.z = 5;
        bigRock1.position.x = -12;
        bigRock1.position.z = -7;

        bigRock.castShadow =
          bigRock1.castShadow =
          smallRock.castShadow =
          smallRock1.castShadow =
            true;
        bigRock.receiveShadow =
          bigRock1.receiveShadow =
          smallRock.receiveShadow =
          smallRock1.receiveShadow =
            true;

        //tree trunks

        let trunk1 = new THREE.Mesh(
          new THREE.BoxGeometry(3, 5, 3),
          new THREE.MeshPhongMaterial({
            color: colorBrown,
            flatShading: true,
            shininess: 0,
          })
        );

        let trunk2 = trunk1.clone();
        let trunk3 = trunk1.clone();
        let trunk4 = trunk1.clone();

        trunk1.position.set(-11.5, 1.5, -15);
        trunk2.position.set(-2, 1.5, -18);
        trunk3.position.set(7, 1.5, -23);
        trunk4.position.set(12.5, 1.5, -18.5);

        trunk1.receiveShadow =
          trunk1.castShadow =
          trunk2.receiveShadow =
          trunk2.castShadow =
          trunk3.receiveShadow =
          trunk3.castShadow =
          trunk4.receiveShadow =
          trunk4.castShadow =
            true;
        let staticElements = new THREE.Group();
        staticElements.add(
          trunk1,
          trunk2,
          trunk3,
          trunk4,
          bigRock,
          smallRock,
          smallRock1,
          bigRock1
        );
        scene.add(staticElements);

        //add elements' positions to the list of obstacles
        let bigRockPos = bigRock.position.clone();
        let smallRockPos = smallRock.position.clone();
        let bigRock1Pos = bigRock1.position.clone();
        let smallRock1Pos = smallRock1.position.clone();
        obstcls.push(bigRockPos, smallRockPos, bigRock1Pos, smallRock1Pos);
        let trunk1Pos = trunk1.position.clone();
        let trunk2Pos = trunk2.position.clone();
        let trunk3Pos = trunk3.position.clone();
        let trunk4Pos = trunk4.position.clone();
        obstcls.push(trunk1Pos, trunk2Pos, trunk3Pos, trunk4Pos);

        //bushes and leaves for trees(that move)
        const bgGeometries = [];
        const colorleaf = [];
        const upPart = new THREE.TorusGeometry(1.7, 3, 10, 15);
        for (let i = 0; i < upPart.attributes.position.count; i++)
          colorleaf.push(colorGreen.r, colorGreen.g, colorGreen.b);
        // add color attribute to the upPart buffer geometry
        upPart.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorleaf), 3)
        );
        const downPart = new THREE.TorusGeometry(1.7, 3, 10, 15);
        downPart.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorleaf), 3)
        );

        upPart.rotateX(1.6, 0, 0);
        downPart.rotateX(1.6, 0, 0);
        upPart.translate(-6, 7, -10);
        downPart.translate(-6, 5.5, -10);
        let upPart2 = upPart.clone();
        let upPart3 = upPart.clone();
        let upPart4 = upPart.clone();
        let downPart2 = downPart.clone();
        let downPart3 = downPart.clone();
        let downPart4 = downPart.clone();

        upPart2.translate(22, 0, -3);
        downPart2.translate(22, 0, -3);
        upPart3.translate(17, 0, -8);
        downPart3.translate(17, 0, -8);
        upPart4.translate(9, 0, -3);
        downPart4.translate(9, 0, -3);

        bgGeometries.push(
          upPart,
          downPart,
          upPart2,
          downPart2,
          upPart3,
          downPart3,
          upPart4,
          downPart4
        );
        //bushes
        const bush = new THREE.SphereGeometry(1, 8, 5);
        bush.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorleaf), 3)
        );
        bush.rotateZ(1.6, 0, 0);
        bush.translate(-9, -0.5, 5);
        bgGeometries.push(bush);

        const bigBush = new THREE.SphereGeometry(1.7, 8, 5);
        bigBush.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorleaf), 3)
        );
        bigBush.rotateX(1.6, 0, 0);
        bigBush.translate(-8, -0.5, 3);
        bgGeometries.push(bigBush);

        const smallBush = new THREE.SphereGeometry(0.8, 6, 4);
        smallBush.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorleaf), 3)
        );
        smallBush.rotateZ(1.2, 0, 0);
        smallBush.translate(-7, -0.5, 5);
        bgGeometries.push(smallBush);

        let bigBush1 = bigBush.clone(),
          bigBush2 = bigBush.clone(),
          bigBush3 = bigBush.clone(),
          bigBush4 = bigBush.clone(),
          bigBush5 = bigBush.clone(),
          bigBush6 = bigBush.clone(),
          bigBush7 = bigBush.clone();
        bigBush1.translate(0, 0, -10);
        bigBush2.translate(2, 0, -20);
        bigBush3.translate(8, 0, -17);
        bigBush4.translate(21, 0, -18);
        bigBush5.translate(26.5, 0, -18);
        bigBush6.translate(16, 0, -21);
        bigBush7.translate(12, 0, -19);
        bgGeometries.push(
          bigBush1,
          bigBush2,
          bigBush3,
          bigBush4,
          bigBush5,
          bigBush6,
          bigBush7
        );

        let bush1 = bush.clone(),
          bush2 = bush.clone(),
          bush3 = bush.clone(),
          bush4 = bush.clone();
        bush1.translate(5.5, 0, -15);
        bush2.translate(18, 0, -21);
        bush3.translate(14.5, 0, -17);
        bush4.translate(23, 0, -18);
        bgGeometries.push(bush1, bush2, bush3, bush4);

        let smallBush1 = smallBush.clone(),
          smallBush2 = smallBush.clone(),
          smallBush3 = smallBush.clone(),
          smallBush4 = smallBush.clone();
        smallBush1.translate(11, 0, -16);
        smallBush2.translate(24, 0, -16);
        smallBush3.translate(1, 0, -13);
        smallBush4.translate(23, 0, -18);
        bgGeometries.push(smallBush1, smallBush2, smallBush3, smallBush4);
        bush.translate(0, 0, 4);
        bigBush.translate(0, 0, 4);
        smallBush.translate(0, 0, 4);

        let bigBushes1 = bigBush.clone(),
          bigBushes2 = bigBush.clone();
        bigBushes1.translate(26, 0, 1);
        bigBushes2.translate(26, 0, -12);
        bgGeometries.push(bigBushes1, bigBushes2);

        let Bushes1 = bush.clone(),
          Bushes2 = bush.clone();
        Bushes1.translate(28, 0, -3);
        Bushes2.translate(0, 0, -11);
        bgGeometries.push(Bushes1, Bushes2);

        let smallBushes1 = smallBush.clone(),
          smallBushes2 = smallBush.clone(),
          smallBushes3 = smallBush.clone();
        smallBushes1.translate(23, 0, 0);
        smallBushes2.translate(5, 0, -1);
        smallBushes3.translate(22, 0, -3);
        bgGeometries.push(smallBushes1, smallBushes2, smallBushes3);

        // let bushPos = bush.position.clone();
        // let bigBushPos = bigBush.position.clone(); let smallBushPos = smallBush.position.clone();
        // obstcls.push(bushPos, bigBushPos, smallBushPos)
        // obstcls.push(bush, bigBush, smallBush, bigBush1, bigBush2, bigBush3, bigBush4, bigBush5, bigBush6, bigBush7,bush1, bush2, bush3, bush4, smallBush1, smallBush2, smallBush3, smallBush4, bigBushes1, bigBushes2,Bushes1, Bushes2)
        //----------------------------------------------------------------

        // orange cat
        const bgGeometry =
          BufferGeometryUtils.mergeBufferGeometries(bgGeometries);
        bg = new THREE.Mesh(
          bgGeometry,
          new THREE.MeshPhongMaterial({
            vertexColors: true,
            flatShading: true,
            shininess: 0,
          })
        );
        bg.receiveShadow = true;
        bg.castShadow = true;
        bg.position.x = -5;
        bg.position.z = -4;
        bg.scale.x = 1.1;
        bg.scale.z = 1.1;
        bg.scale.y = 1.1;
        scene.add(bg);

        const oHead = new THREE.Mesh(
          new THREE.BoxGeometry(2.2, 1.6, 2),
          new THREE.MeshStandardMaterial({
            color: colorOrange,
          })
        );
        oHead.position.y = 1.5;
        oHead.receiveShadow = oHead.castShadow = true;

        oEarL = new THREE.Mesh(
          new THREE.BoxGeometry(0.6, 0.4, 0.4),
          new THREE.MeshStandardMaterial({
            color: colorOrange,
          })
        );
        oEarL.position.x = 0.7;
        oEarL.position.y = 2.5;
        oEarL.position.z = 0.5;
        oEarL.receiveShadow = oEarL.castShadow = true;

        oEarR = oEarL.clone();
        oEarR.position.x = -0.7;

        let oWhiskers = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 0.07, 0.05),
          new THREE.MeshStandardMaterial({
            color: colorGray,
          })
        );
        oWhiskers.position.x = 0.5;
        oWhiskers.position.y = 1.1;
        oWhiskers.position.z = 1;
        oWhiskers.rotation.z = 0.2;
        oWhiskers.receiveShadow = oWhiskers.castShadow = true;

        let oWhiskers2 = oWhiskers.clone();
        oWhiskers2.position.y = 0.9;
        oWhiskers2.rotation.z = -0.2;

        let oWhiskers3 = oWhiskers.clone();
        oWhiskers3.position.x = -0.5;
        oWhiskers3.rotation.z = -0.2;

        let oWhiskers4 = oWhiskers.clone();
        oWhiskers4.position.x = -0.5;
        oWhiskers4.position.y = 0.9;

        const oEyeL = new THREE.Mesh(
          new THREE.SphereGeometry(0.2, 7, 5),
          new THREE.MeshStandardMaterial({
            color: colorGray,
            roughness: 0.4,
          })
        );
        oEyeL.position.x = 0.75;
        oEyeL.position.y = 1.7;
        oEyeL.position.z = 0.9;
        oEyeL.receiveShadow = oEyeL.castShadow = true;

        const oEyeR = oEyeL.clone();
        oEyeR.position.x = -0.75;

        const oNose = new THREE.Mesh(
          new THREE.SphereGeometry(0.1, 7, 5),
          new THREE.MeshStandardMaterial({
            color: colorGray,
            roughness: 0.4,
          })
        );
        oNose.position.y = 1.35;
        oNose.position.z = 1.2;
        oNose.receiveShadow = oNose.castShadow = true;

        const oHeadSpot = new THREE.Mesh(
          new THREE.BoxGeometry(0.8, 0.5, 2.1),
          new THREE.MeshStandardMaterial({
            color: colorWhite,
          })
        );
        oHeadSpot.position.y = 2.1;
        oHeadSpot.receiveShadow = oHeadSpot.castShadow = true;

        const oHead2 = new THREE.Mesh(
          new THREE.BoxGeometry(0.7, 0.6, 0.2),
          new THREE.MeshStandardMaterial({
            color: colorWhite,
          })
        );
        oHead2.position.y = 1;
        oHead2.position.z = 1.1;
        oHead2.receiveShadow = oHead2.castShadow = true;

        const oMouth = new THREE.Mesh(
          new THREE.CircleGeometry(0.05, 10),
          new THREE.MeshStandardMaterial({
            color: colorGray,
            roughness: 0.4,
          })
        );
        oMouth.position.y = 1.1;
        oMouth.position.z = 1.21;
        oMouth.receiveShadow = true;

        const oBlushL = new THREE.Mesh(
          new THREE.PlaneGeometry(0.4, 0.2),
          new THREE.MeshStandardMaterial({
            color: colorPink,
          })
        );
        oBlushL.position.x = 0.75;
        oBlushL.position.y = -0.2;
        oBlushL.position.z = 1.01;
        oBlushL.receiveShadow = true;

        const oBlushR = oBlushL.clone();
        oBlushR.position.x = -0.75;

        oHead.add(oBlushL, oBlushR);

        const oEarPinkL = oBlushL.clone();
        oEarPinkL.position.x = 0;
        oEarPinkL.position.y = 0;
        oEarPinkL.position.z = 0.21;

        const oEarPinkR = oEarPinkL.clone();

        oEarL.add(oEarPinkL);
        oEarR.add(oEarPinkR);

        let headGroup = new THREE.Group();
        headGroup.add(
          oHead,
          oEarL,
          oEarR,
          oWhiskers,
          oWhiskers2,
          oWhiskers3,
          oWhiskers4,
          oEyeL,
          oEyeR,
          oNose,
          oHeadSpot,
          oHead2,
          oMouth
        );

        // orange cat body
        let oBody = new THREE.Mesh(
          new THREE.BoxGeometry(1.4, 0.85, 1.4),
          new THREE.MeshStandardMaterial({
            color: colorOrange,
          })
        );
        oBody.position.y = 0.15;
        oBody.receiveShadow = oBody.castShadow = true;

        let oTail = new THREE.Mesh(
          new THREE.SphereGeometry(0.2, 5, 3),
          new THREE.MeshStandardMaterial({
            color: colorWhite,
          })
        );
        oTail.position.z = -0.8;
        oTail.receiveShadow = oTail.castShadow = true;

        let oBody2 = new THREE.Mesh(
          new THREE.BoxGeometry(0.7, 0.65, 1),
          new THREE.MeshStandardMaterial({
            color: colorWhite,
          })
        );
        oBody2.position.y = 0.03;
        oBody2.position.z = 0.25;
        oBody2.receiveShadow = oBody2.castShadow = true;

        let bodyGroup = new THREE.Group();
        bodyGroup.add(oBody, oTail, oBody2);

        // orange cat collar
        let oCollar = new THREE.Mesh(
          new THREE.BoxGeometry(1.7, 0.2, 1.8),
          new THREE.MeshStandardMaterial({
            color: colorGreen,
          })
        );
        oCollar.position.y = 0.6;
        oCollar.receiveShadow = oCollar.castShadow = true;

        let oBell = new THREE.Mesh(
          new THREE.SphereGeometry(0.2, 7, 5),
          new THREE.MeshStandardMaterial({
            color: colorYellow,
            roughness: 0.4,
          })
        );
        oBell.position.y = 0.4;
        oBell.position.z = 0.9;
        oBell.receiveShadow = oBell.castShadow = true;

        let collarGroup = new THREE.Group();
        collarGroup.add(oCollar, oBell);

        // arms
        let oArmL = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 0.6, 0.3),
          new THREE.MeshPhongMaterial({
            color: colorOrange,
          })
        );
        oArmL.position.x = 0.8;
        oArmL.position.y = 0.1;
        oArmL.rotation.x = -1.5;
        oArmL.receiveShadow = oArmL.castShadow = true;

        let oArmR = oArmL.clone();
        oArmR.position.x = -0.8;
        oArmR.rotation.x = 0;

        let oArmL2 = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 0.3, 0.3),
          new THREE.MeshPhongMaterial({
            color: colorWhite,
          })
        );
        oArmL2.position.x = 0.8;
        oArmL2.position.y = 0.07;
        oArmL2.position.z = 0.44;
        oArmL2.rotation.x = -1.5;
        oArmL2.receiveShadow = oArmL2.castShadow = true;

        let oArmR2 = oArmL2.clone();
        oArmR2.position.x = -0.8;
        oArmR2.position.y = -0.35;
        oArmR2.position.z = 0;
        oArmR2.rotation.x = 0;

        arm1 = new THREE.Group();
        arm1.add(oArmL, oArmL2);

        let arm2 = new THREE.Group();
        arm2.add(oArmR, oArmR2);

        // legs
        let oLegL = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.3, 0.4),
          new THREE.MeshPhongMaterial({
            color: colorOrange,
          })
        );
        oLegL.position.x = 0.5;
        oLegL.position.y = -0.4;
        oLegL.receiveShadow = oLegL.castShadow = true;

        let oLegR = oLegL.clone();
        oLegR.position.x = -0.5;

        let oLegL2 = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.2, 0.4),
          new THREE.MeshPhongMaterial({
            color: colorWhite,
          })
        );
        oLegL2.position.y = -0.25;
        oLegL2.receiveShadow = oLegL2.castShadow = true;

        let oLegR2 = oLegL2.clone();

        oLegL.add(oLegL2);

        oLegR.add(oLegR2);

        // watering pot
        let cyl = new THREE.Mesh(
          new THREE.CylinderGeometry(0.4, 0.4, 0.6),
          new THREE.MeshStandardMaterial({
            color: colorGray,
            roughness: 0.4,
          })
        );
        cyl.position.x = 0.8;
        cyl.position.y = 0;
        cyl.position.z = 1.2;
        cyl.receiveShadow = cyl.castShadow = true;

        let cyl2 = new THREE.Mesh(
          new THREE.CylinderGeometry(0.15, 0.15, 0.6),
          new THREE.MeshStandardMaterial({
            color: colorGray,
            roughness: 0.4,
          })
        );
        cyl2.position.x = 0.8;
        cyl2.position.y = 0.1;
        cyl2.position.z = 1.65;
        cyl2.rotation.x = 0.7;
        cyl2.receiveShadow = cyl2.castShadow = true;

        let box = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 0.2, 0.3),
          new THREE.MeshStandardMaterial({
            color: colorGray,
            roughness: 0.4,
          })
        );
        box.position.x = 0.8;
        box.position.y = 0;
        box.position.z = 0.7;
        box.receiveShadow = box.castShadow = true;

        let circ = new THREE.Mesh(
          new THREE.CircleGeometry(0.3, 10),
          new THREE.MeshStandardMaterial({
            color: colorBlue,
            roughness: 0.4,
          })
        );
        circ.position.x = 0.8;
        circ.position.y = 0.31;
        circ.position.z = 1.2;
        circ.rotation.x = -1.6;
        circ.receiveShadow = true;

        let wateringPot = new THREE.Group();
        wateringPot.add(cyl, cyl2, box, circ);

        arm1.add(wateringPot);

        orangeKitty = new THREE.Group();
        orangeKitty.position.x = -5;
        orangeKitty.add(
          headGroup,
          bodyGroup,
          collarGroup,
          oLegL,
          oLegR,
          arm1,
          arm2
        );
        scene.add(orangeKitty);

        // black cat

        const catGeometries = [];

        const body = new THREE.BoxGeometry(1.5, 1, 1);
        const colorsBody = []; // array of colors for each vertex of the leaves geometry
        // Do this ONLY ONCE, since ALL 3 level catGeometries have the SAME number of vertices
        for (let i = 0; i < body.attributes.position.count; i++)
          colorsBody.push(colorGray.r, colorGray.g, colorGray.b);
        //body
        body.translate(0, 0.2, 0);
        // add color attribute to the body buffer geometry
        body.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorsBody), 3)
        );
        catGeometries.push(body);

        const head = new THREE.BoxGeometry(2.25, 1.7, 1.6);
        head.translate(0, 1.55, 0);
        head.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorsBody), 3)
        );
        catGeometries.push(head);

        const snout = new THREE.BoxGeometry(2, 0.5, 0.3);
        snout.translate(0, 0.95, 0.9);
        snout.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorsBody), 3)
        );
        catGeometries.push(snout);

        //forehead
        const forehead = new THREE.BoxGeometry(0.84, 0.5, 1.62);
        const colorsWhite = [];
        for (let i = 0; i < forehead.attributes.position.count; i++)
          colorsWhite.push(colorWhite.r, colorWhite.g, colorWhite.b);
        forehead.translate(0, 2.16, 0);
        forehead.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorsWhite), 3)
        );
        catGeometries.push(forehead);

        //--> cheeks
        const cheekl = new THREE.BoxGeometry(0.4, 0.2, 0.1);
        const colorsPinkw = [];
        for (let i = 0; i < cheekl.attributes.position.count; i++)
          colorsPinkw.push(colorPink.r, colorPink.g, colorPink.b);
        cheekl.translate(-0.93, 0.81, 1.1);
        cheekl.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorsPinkw), 3)
        );
        catGeometries.push(cheekl);

        const cheekr = new THREE.BoxGeometry(0.4, 0.2, 0.1);
        cheekr.translate(0.93, 0.81, 1.1);
        cheekr.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorsPinkw), 3)
        );
        catGeometries.push(cheekr);

        //colar
        const colar = new THREE.BoxGeometry(1.7, 0.5, 1.2);
        const colorsPurple = [];
        for (let i = 0; i < colar.attributes.position.count; i++)
          colorsPurple.push(colorPurple.r, colorPurple.g, colorPurple.b);
        colar.translate(0, 0.7, 0);
        colar.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorsPurple), 3)
        );
        catGeometries.push(colar);

        //whiskers
        const whiskerl = new THREE.CylinderGeometry(0.06, 0.06, 0.5, 4, 1);
        const colorsBlack = [];
        for (let i = 0; i < whiskerl.attributes.position.count; i++)
          colorsBlack.push(colorBlack.r, colorBlack.g, colorBlack.b);
        whiskerl.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorsBlack), 3)
        );
        whiskerl.translate(0.9, 1.2, 0.7);
        whiskerl.rotateZ(1.6, 0, 0);
        const whiskerl2 = whiskerl.clone();
        whiskerl2.translate(0, 0.3, 0);
        catGeometries.push(whiskerl, whiskerl2);

        const whiskerr = new THREE.CylinderGeometry(0.06, 0.06, 0.5, 4, 1);
        whiskerr.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorsBlack), 3)
        );
        whiskerr.translate(0.9, -1.2, 0.7);
        whiskerr.rotateZ(1.6, 0, 0);
        const whiskerr2 = whiskerr.clone();
        whiskerr2.translate(0, 0.3, 0);
        catGeometries.push(whiskerr, whiskerr2);

        //mesh/adding cat to scene
        const blackCatGeometry =
          BufferGeometryUtils.mergeBufferGeometries(catGeometries);
        blackCat = new THREE.Mesh(
          blackCatGeometry,
          new THREE.MeshPhongMaterial({
            vertexColors: true,
            flatShading: true,
            shininess: 0,
          })
        );
        blackCat.castShadow = true;
        blackCat.receiveShadow = true;

        // eyes and nose and bell(shiny parts)
        const shinyGeometries = [];
        const eyel = new THREE.SphereGeometry(0.25, 4, 10);
        eyel.rotateX(1.6, 0, 0);
        eyel.rotateZ(0.8, 0, 0);
        eyel.translate(-0.7, 1.35, 0.7);
        const colorshinyBlack = [];
        for (let i = 0; i < eyel.attributes.position.count; i++)
          colorshinyBlack.push(colorBlack.r, colorBlack.g, colorBlack.b);
        eyel.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorshinyBlack), 3)
        );
        shinyGeometries.push(eyel);

        const eyer = new THREE.SphereGeometry(0.25, 4, 10);
        eyer.rotateX(1.6, 0, 0);
        eyer.rotateZ(0.8, 0, 0);
        eyer.translate(0.7, 1.35, 0.7);
        eyer.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorshinyBlack), 3)
        );
        shinyGeometries.push(eyer);

        //lil nose
        const nose = new THREE.BoxGeometry(0.3, 0.1, 0.3);
        nose.translate(0, 1.1, 1);
        nose.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorshinyBlack), 3)
        );
        shinyGeometries.push(nose);

        const shinyGeometry =
          BufferGeometryUtils.mergeBufferGeometries(shinyGeometries);
        features = new THREE.Mesh(
          shinyGeometry,
          new THREE.MeshPhysicalMaterial({
            vertexColors: true,
            metalness: 0.2,
            roughness: 0.1,
            flatShading: true,
          })
        );
        features.castShadow = true;
        features.receiveShadow = true;

        // parts that move-----------------------------------------------------------------------------------------------------------------------

        // legs
        legl = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.7, 0.6),
          new THREE.MeshPhongMaterial({
            color: colorWhite,
            flatShading: true,
            shininess: 0,
          })
        );
        legl.position.x = -0.49;
        legl.position.y = -0.4;
        legl.receiveShadow = legl.castShadow = true;

        legr = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.7, 0.6),
          new THREE.MeshPhongMaterial({
            color: colorWhite,
            flatShading: true,
            shininess: 0,
          })
        );
        legr.position.x = 0.49;
        legr.position.y = -0.4;
        legr.receiveShadow = legr.castShadow = true;

        //arms
        shoulderl = new THREE.Object3D();
        shoulderl.position.set(-0.7, 0.35, 0);
        shoulderl.rotation.z = THREE.Math.degToRad(20);
        scene.add(shoulderl);

        armUpl = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.5, 0.5),
          new THREE.MeshPhongMaterial({
            color: colorGray,
            flatShading: true,
            shininess: 0,
          })
        );
        armUpl.position.set(-0.25, 0, 0);
        // armUpl.rotateZ(0.3,0.3,1);
        shoulderl.add(armUpl);
        armUpl.receiveShadow = armUpl.castShadow = true;

        shoulderr = new THREE.Object3D();
        shoulderr.position.set(0.7, 0.35, 0);
        shoulderr.rotation.z = THREE.Math.degToRad(-20);
        scene.add(shoulderr);

        armUpr = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.5, 0.5),
          new THREE.MeshPhongMaterial({
            color: colorGray,
            flatShading: true,
            shininess: 0,
          })
        );
        armUpr.position.set(0.25, 0, 0);
        shoulderr.add(armUpr);
        armUpr.receiveShadow = armUpr.castShadow = true;
        //forearms

        elbowl = new THREE.Object3D();
        elbowl.position.set(-0.25, 0, 0);
        armUpl.add(elbowl);

        forearml = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 0.5, 0.5),
          new THREE.MeshPhongMaterial({
            color: colorWhite,
            flatShading: true,
            shininess: 0,
          })
        );
        forearml.position.set(-0.15, 0, 0);
        elbowl.add(forearml);
        forearml.receiveShadow = forearml.castShadow = true;

        elbowr = new THREE.Object3D();
        elbowr.position.set(0.25, 0, 0);
        armUpr.add(elbowr);

        forearmr = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 0.5, 0.5),
          new THREE.MeshPhongMaterial({
            color: colorWhite,
            flatShading: true,
            shininess: 0,
          })
        );
        forearmr.position.set(0.15, 0, 0);
        elbowr.add(forearmr);
        forearmr.receiveShadow = forearmr.castShadow = true;

        //  ears(rectangular)
        let leftEarG = [];
        let rightEarG = [];

        const outEarl = new THREE.BoxGeometry(0.7, 0.4, 0.7);
        outEarl.translate(-0.79, 2.6, 0.47);
        const colorGrayEar = [];
        for (let i = 0; i < outEarl.attributes.position.count; i++)
          colorGrayEar.push(colorGray.r, colorGray.g, colorGray.b);
        outEarl.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorGrayEar), 3)
        );
        leftEarG.push(outEarl);

        const outEarr = new THREE.BoxGeometry(0.7, 0.4, 0.7);
        outEarr.translate(0.79, 2.6, 0.47);
        outEarr.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorGrayEar), 3)
        );
        rightEarG.push(outEarr);

        const inEarl = new THREE.BoxGeometry(0.4, 0.4, 0.4);
        inEarl.translate(-0.95, 2.3, 0.621);
        const colorPinkEar = [];
        for (let i = 0; i < inEarl.attributes.position.count; i++)
          colorPinkEar.push(colorPink.r, colorPink.g, colorPink.b);
        inEarl.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorPinkEar), 3)
        );
        leftEarG.push(inEarl);

        const inEarr = new THREE.BoxGeometry(0.4, 0.4, 0.4);
        inEarr.translate(0.95, 2.3, 0.621);
        inEarr.setAttribute(
          "color",
          new THREE.BufferAttribute(new Float32Array(colorPinkEar), 3)
        );
        rightEarG.push(inEarr);

        earl = new THREE.Mesh(
          BufferGeometryUtils.mergeBufferGeometries(leftEarG),
          new THREE.MeshPhongMaterial({
            vertexColors: true,
            flatShading: true,
            shininess: 0,
          })
        );
        earl.castShadow = true;
        earl.receiveShadow = true;

        earr = new THREE.Mesh(
          BufferGeometryUtils.mergeBufferGeometries(rightEarG),
          new THREE.MeshPhongMaterial({
            vertexColors: true,
            flatShading: true,
            shininess: 0,
          })
        );
        earr.castShadow = true;
        earr.receiveShadow = true;

        //tail
        tail = new THREE.Mesh(
          new THREE.CylinderGeometry(0.05, 0.4, 1, 6),
          new THREE.MeshPhongMaterial({
            color: colorGray,
            flatShading: true,
            shininess: 0,
          })
        );
        tail.rotation.x = THREE.Math.degToRad(-70);
        tail.position.y = 0.3;
        tail.position.z = -0.7;
        tail.castShadow = tail.receiveShadow = true;

        // bell
        bell = new THREE.Mesh(
          new THREE.SphereGeometry(0.3, 8, 5),
          new THREE.MeshStandardMaterial({
            color: colorYellow,
            flatShading: true,
            metalness: 0.5,
            roughness: 0.2,
          })
        );
        bell.position.y = 0.3;
        bell.position.z = 0.7;
        bell.castShadow = true;
        bell.receiveShadow = true;

        //group everything together
        blackKittybody = new THREE.Group();
        blackKittybody.add(
          blackCat,
          shoulderl,
          shoulderr,
          features,
          legl,
          legr,
          earl,
          earr
        );
        blackKitty = new THREE.Group();
        blackKitty.add(blackKittybody, bell, tail);
        scene.add(blackKitty);

        //animations
        // SAVE initial vertices coordinates and settings for their circular motion
        for (let i = 0; i < bg.geometry.attributes.position.count; i++) {
          verts.push({
            x: bg.geometry.attributes.position.getX(i),
            y: bg.geometry.attributes.position.getY(i),

            ang: Math.random() * Math.PI * 2, // initial angle
            amp: -0.1 + Math.random() * 0.2, // radius
            speed: 0.02 + Math.random() * 0.02, // angular velocity
          });
        }

        // ---------------------------------------------------------------------
        // white cat

        let whiteCatGeometries = [];

        // body
        const wBody = new THREE.BoxGeometry(1.5, 1, 1);
        const colorsBege = []; 
        for (let i = 0; i < wBody.attributes.position.count; i++)
            colorsBege.push(colorBege.r, colorBege.g, colorBege.b);
        wBody.translate(0, 0.2, 0)
        wBody.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorsBege), 3));
        whiteCatGeometries.push(wBody);

        // head
        const wHead = new THREE.BoxGeometry(2.25, 1.7, 1.6);
        wHead.translate(0, 1.55, 0)
        wHead.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorsBege), 3));
        whiteCatGeometries.push(wHead);

        // snout
        const wSnout = new THREE.BoxGeometry(2, 0.65, 0.25);
        wSnout.translate(0, 1.02, 0.87)
        wSnout.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorsBege), 3));
        whiteCatGeometries.push(wSnout);

        // ears
        const wEarOutL = new THREE.BoxGeometry(0.5,0.35,0.2);
        wEarOutL.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorsBege), 3));
        wEarOutL.translate(-0.85,2.55,0.7);
        const wEarOutR = wEarOutL.clone();
        wEarOutR.translate(1.7, 0,0);

        const wEarInL = new THREE.BoxGeometry(0.35,0.2,0.1);
        const colorswPink = []; 
        for (let i = 0; i < wEarInL.attributes.position.count; i++)
            colorswPink.push(colorPinkw.r, colorPinkw.g, colorPinkw.b);
        wEarInL.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorswPink), 3));
        wEarInL.translate(-0.88,2.5,0.77);
        const wEarInR = wEarInL.clone();
        wEarInR.translate(1.75,0,0);
        whiteCatGeometries.push(wEarOutL,wEarOutR, wEarInL, wEarInR);

        // nose
        const wNose = new THREE.BoxGeometry(0.2,0.1,0.02);
        wNose.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorswPink), 3));
        wNose.translate(0,1.2,1);
        whiteCatGeometries.push(wNose);

        // forehead
        const wForehead = new THREE.BoxGeometry(0.85, 0.5, 1.62);
        const colorsLightPurple = []; 
        for (let i = 0; i < wForehead.attributes.position.count; i++)
            colorsLightPurple.push(colorLightPurple.r, colorLightPurple.g, colorLightPurple.b);
        wForehead.translate(0, 2.16,0);
        wForehead.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorsLightPurple), 3));
        whiteCatGeometries.push(wForehead);

        // colar
        const wColar = new THREE.BoxGeometry(1.7, 0.5, 1.2);
        const colorsDarkPurple = [];
        for (let i = 0; i < wColar.attributes.position.count; i++)
            colorsDarkPurple.push(colorDarkPurple.r, colorDarkPurple.g, colorDarkPurple.b);
        wColar.translate(0, 0.7, 0);
        wColar.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorsDarkPurple), 3));
        whiteCatGeometries.push(wColar); 

        // blush
        const wBlushL = new THREE.BoxGeometry(0.3, 0.18, 0.05);
        const colorsBlush = [];
        for (let i = 0; i < wBlushL.attributes.position.count; i++)
            colorsBlush.push(colorBlush.r, colorBlush.g, colorBlush.b);
        wBlushL.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorsBlush), 3));
        wBlushL.translate(0.845, 0.79, 1);
        const wBlushR = wBlushL.clone();
        wBlushR.translate(-1.685,0,0)
        whiteCatGeometries.push(wBlushL, wBlushR);

        // tail
        const wTail = new THREE.SphereGeometry(0.1, 20, 20);
        const colorsTail = []; 
        for (let i = 0; i < wTail.attributes.position.count; i++)
            colorsTail.push(colorTail.r, colorTail.g, colorTail.b);
        wTail.translate(0,0,-0.55);
        wTail.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorsTail), 3));
        whiteCatGeometries.push(wTail);

        // whiskers left
        const wWhiskersL = new THREE.CylinderGeometry(0.03, 0.03, 0.5,20,1);
        const colorswBlack = [];
        for (let i = 0; i < wWhiskersL.attributes.position.count; i++)
            colorswBlack.push(colorBlack.r, colorBlack.g, colorBlack.b);
        wWhiskersL.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorswBlack), 3));
        wWhiskersL.translate(0.9, 1.2, 0.7);
        wWhiskersL.rotateZ(1.6,0,0);
        const wWhiskersL2 = wWhiskersL.clone();
        wWhiskersL2.translate(0, 0.25,0);
        whiteCatGeometries.push(wWhiskersL, wWhiskersL2);

        // whiskers right
        const wWhiskersR = new THREE.CylinderGeometry(0.03, 0.03, 0.5,20,1);
        wWhiskersR.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorswBlack), 3));
        wWhiskersR.translate(0.9, -1.2, 0.7);
        wWhiskersR.rotateZ(1.6,0,0);
        const wWhiskersR2 = wWhiskersR.clone();
        wWhiskersR2.translate(0, 0.25,0);
        whiteCatGeometries.push(wWhiskersR, wWhiskersR2);

        // mouth
        class CustomSinCurve extends THREE.Curve {
          constructor( scale = 1 ) {
              super();
              this.scale = scale;
          }

          getPoint( t, optionalTarget = new THREE.Vector3() ) {
              const tx = t * 3 - 1.5;
              const ty = Math.sin(-3.05 * Math.PI * t )*0.35;
              const tz = 0;
              return optionalTarget.set( tx, ty, tz ).multiplyScalar( this.scale );
          }
        }
        const path = new CustomSinCurve( 0.15);
        const wMouth = new THREE.TubeGeometry( path, 20, 0.03, 20, false );
        wMouth.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorswBlack), 3));
        wMouth.translate(0,1,1);
        whiteCatGeometries.push(wMouth);

        // bell
        pointBell = new THREE.Object3D();
        pointBell.position.set(0.015, 0.7, 0.2);
        scene.add(pointBell);

        wBell = new THREE.Mesh(
          new THREE.SphereGeometry(0.2, 10, 8),
          new THREE.MeshStandardMaterial({
            color: colorYellow,
            flatShading: true,
            metalness: 0.2,
            roughness: 0.2,
          })
        );
        wBell.position.y = -0.3;
        wBell.position.z = 0.55;
        wBell.castShadow = true;
        wBell.receiveShadow = true;
        pointBell.add(wBell);

        // shiny geometries
        const wShinyGeometries = [];

        // eyes 
        const wEyeL = new THREE.SphereGeometry(0.13,10,10);
        wEyeL.setAttribute(
            'color',
            new THREE.BufferAttribute(new Float32Array(colorswBlack), 3));
        wEyeL.translate(-0.6, 1.45, 0.8);
        const wEyeR = wEyeL.clone();
        wEyeR.translate(1.2,0,0);
        wShinyGeometries.push(wEyeL, wEyeR);

        const wShiny = new THREE.Mesh(
          BufferGeometryUtils.mergeBufferGeometries(wShinyGeometries),
          new THREE.MeshPhysicalMaterial({
              vertexColors: true,
              flatShading: true,
              metalness: 0.1,
              roughness: 0.2,
              // shininess: 0,
          })
        );

        wShiny.castShadow = true;
        wShiny.receiveShadow = true;

        // move it move it
        // legs
        let wLegL = new THREE.Mesh(
        new THREE.BoxGeometry(0.5, 0.75, 0.6),
        new THREE.MeshPhongMaterial({ color: colorBege, flatShading: true, shininess: 0}));
        wLegL.position.x = -0.49;
        wLegL.position.y = -0.4;
        wLegL.receiveShadow = wLegL.castShadow = true;

        let wLegR = new THREE.Mesh(
        new THREE.BoxGeometry(0.5, 0.75, 0.6),
        new THREE.MeshPhongMaterial({ color: colorBege, flatShading: true, shininess: 0}));
        wLegR.position.x = 0.49;
        wLegR.position.y = -0.4;
        wLegR.receiveShadow = wLegR.castShadow = true;

        // his left arm 
        // shoulder
        wShoulderL = new THREE.Object3D();
        wShoulderL.position.set(0.65,0.35,0);
        wShoulderL.rotation.z = THREE.Math.degToRad(135);
        scene.add(wShoulderL);

        // arm
        let wArmL = new THREE.Mesh(
        new THREE.BoxGeometry(1.2, 0.4, 0.4),
        new THREE.MeshPhongMaterial({ color: colorBege, flatShading: true, shininess: 0}));
        wArmL.position.set(-0.25, 0, 0);
        wShoulderL.add(wArmL);
        wArmL.receiveShadow = wArmL.castShadow = true;

        // his right arm 
        // shoulder
        wShoulderR = new THREE.Object3D();
        wShoulderR.position.set(-0.65, 0.35, 0);
        wShoulderR.rotation.z = THREE.Math.degToRad(45);
        scene.add(wShoulderR); 

        // arm
        let wArmUpR = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 0.4, 0.4),
        new THREE.MeshPhongMaterial({ color: colorBege, flatShading: true, shininess: 0}));
        wArmUpR.position.set(-0.25, 0, 0);
        wShoulderR.add(wArmUpR);
        wArmUpR.receiveShadow = wArmUpR.castShadow = true;

        // elbow 
        wElbowR = new THREE.Object3D();
        wElbowR.position.set(-0.2, 0, 0);
        wArmUpR.add(wElbowR); 

        // forearm 
        wArmDownR = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.4, 0.4),
        new THREE.MeshPhongMaterial({ color: colorBege, flatShading: true, shininess: 0}));
        wArmDownR.position.set(-0.25, 0, 0);
        wElbowR.add(wArmDownR);
        wArmDownR.receiveShadow = wArmDownR.castShadow = true;

        // show cat
        whiteCatGeometries = BufferGeometryUtils.mergeBufferGeometries(whiteCatGeometries);
            
        const whiteCat = new THREE.Mesh(
            whiteCatGeometries,
            new THREE.MeshPhongMaterial({
                vertexColors: true,
                flatShading: true,
                shininess: 0,
            })
        );

        whiteCat.castShadow = true;
        whiteCat.receiveShadow = true;

        whiteKittybody = new THREE.Group();
        whiteKittybody.add(whiteCat, wShiny, wShoulderR, wShoulderL, pointBell);
        whiteKitty = new THREE.Group();
        whiteKitty.add(whiteKittybody, wLegL, wLegR); 
       
        whiteKitty.position.x = 5;
        scene.add(whiteKitty);

        whiteKitty.position.z = blackKitty.position.z = orangeKitty.position.z = 3;

        // ------------------------------------------------------------

        for (let i = 0; i < treeTop.geometry.attributes.position.count; i++) {
          vertsTree.push({
            x: treeTop.geometry.attributes.position.getX(i),
            y: treeTop.geometry.attributes.position.getY(i),

            ang: Math.random() * Math.PI * 2, // initial angle
            amp: -0.1 + Math.random() * 0.2, // radius
            speed: 0.02 + Math.random() * 0.02, // angular velocity
          });
        }

        
        //----------------------------------------------------------------
        // functions

        let i = 0;
        function grow() {
          if(n==0){
            n=1
            waterTree=true
            scene.add(tree);
            scene.remove(arrowHelp);scene.add(heart)
            tree.position.y = -0.5;
            heart.position.z=-5.6
            heart.position.y= -0.1
            setTimeout(function () {
              tree.scale.set(1 / 3, 1 / 3, 1 / 3);
              heart.scale.set(1 / 3, 1 / 3, 1 / 3);
              tree.position.y += 0.3;
              heart.position.z=-5.55
              heart.position.y += 0.3;
              setTimeout(function () {
              tree.scale.set(2 / 3, 2 / 3, 2 / 3);
              heart.scale.set(2 / 3, 2 / 3, 2 / 3);
              tree.position.y += 0.3;
              heart.position.y += 0.3;
              heart.position.z=-4.5
              setTimeout(function () {
              tree.scale.set(1, 1, 1 );
              heart.scale.set(1, 1, 1 );
              tree.position.y += 0.3;
              heart.position.y = 1.3;
              heart.position.z=-3.2
              waterTree=false
            },500)
            },500)
            },500)
          }


          // if (i == 0) {
          //   scene.add(tree);
          //   scene.add(heart);
          //   tree.position.y = -0.5;
          //   heart.position.z= -5.5
          //   heart.position.y= -0.3
          //   i++;
          // } else if (i < 4 && i != 0) {
          //   tree.scale.set(i / 3, i / 3, i / 3);
          //   heart.scale.set(i / 3, i / 3, i / 3);
          //   tree.position.y += 0.3;
          //   heart.position.y += 0.3;
          //   i++;
          // }
        }

        function handleKeyDown(e) {
          e.preventDefault();
          if (event.key == " ") {
            num += 1;
            if (num == 4) {
              num = 1;
            }
          }
          if (num == 1) {
            selectCat = orangeKitty;
          } else if (num == 2) {
            selectCat = blackKitty;
          } else {
            selectCat = whiteKitty;
          }
          if (!started) {
            if (e.key == "Enter") {
              started = true;
              camera.position.x = 0;
              indicator.position.y = 0;
              indicator.rotation.y = 0;
              if(tree.position.y < 0.3){
                setTimeout(() => {
                  scene.add(arrowHelp)
                }, 4000);
              }
            }
          } else if (started) {
            if (e.key == "ArrowRight") {
              rightKey = true;
              if (selectCat) Actions(e);
              Walk(e);
            } else if (e.key == "ArrowLeft") {
              leftKey = true;
              Actions(e);
              Walk(e);
            } else if (e.key == "ArrowUp") {
              upKey = true;
              Actions(e);
              Walk(e);
            } else if (e.key == "ArrowDown") {
              downKey = true;
              Actions(e);
              Walk(e);
            } else if (
              e.key == "x" && num == 2 && n == 1 &&
              blackKitty.position.x <= tree.position.x + 3.5 &&
              blackKitty.position.x >= tree.position.x - 3.5 &&
              blackKitty.position.z <= tree.position.z + 3.5 &&
              blackKitty.position.z >= tree.position.z - 3.5
            ) {
              toShake = true;
              setTimeout(() => {
                toFall = true;
              }, 500);
            } else if (e.key == "x" && num == 1) {
              // arm1.rotation.x +=
              //   ((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.03;
              if (
                spot.position.z + 4 > orangeKitty.position.z &&
                orangeKitty.position.z > spot.position.z - 4 &&
                spot.position.x + 4 > orangeKitty.position.x &&
                orangeKitty.position.x > spot.position.x - 4
              ) {
                waterTree=true
                grow();
              }
            } else if (e.key == "x" && num == 3 && heart.position.y == -0.55 && 
              whiteKitty.position.x <= heart.position.x - 2 + 1.8 &&
              whiteKitty.position.x >= heart.position.x - 2 - 1.8 &&
              whiteKitty.position.z <= heart.position.z + 2 + 1.8 &&
              whiteKitty.position.z >= heart.position.z + 2 - 1.8 ){
              toBend = true;;
            } 

          }
          indicator.position.x = selectCat.position.x;
          indicator.position.z = selectCat.position.z;
          indicator.rotation.x = selectCat.rotation.x;
          indicator.rotation.y = selectCat.rotation.y;
          indicator.rotation.z = selectCat.rotation.z;
        }

        function handleKeyUp(e) {
          if (e.key == "ArrowRight") {
            rightKey = false;
          } else if (e.key == "ArrowLeft") {
            leftKey = false;
          } else if (e.key == "ArrowUp") {
            upKey = false;
          } else if (e.key == "ArrowDown") {
            downKey = false;
          }
          legl.rotation.x = legr.rotation.x = bell.rotation.x = 0;
          shoulderl.rotation.z = THREE.Math.degToRad(20);
          shoulderr.rotation.z = THREE.Math.degToRad(-20);
          earl.rotation.z = earr.rotation.z = 0;
          earl.rotation.x = earr.rotation.x = 0;
          blackKittybody.position.y = 0;

          tail.position.z = -0.7;
          bell.position.z = 0.7;
          blackKittybody.position.z = 0;
          tail.rotation.x = THREE.Math.degToRad(-70);
          earl.rotation.x = earr.rotation.x = 0;
          shoulderl.rotation.y = shoulderr.rotation.y = 0;
          elbowl.rotation.z = elbowr.rotation.z = 0;

          treeTop.rotation.z = 0;

          oLegL.rotation.x =
            oLegR.rotation.x =
            arm2.rotation.x =
            arm1.rotation.x =
              0;

          wLegL.rotation.x = wLegR.rotation.x = 0;
          wShoulderL.rotation.z = THREE.Math.degToRad(135);
          wShoulderR.rotation.z = THREE.Math.degToRad(45);
          wShoulderL.rotation.y = wShoulderR.rotation.y = 0;
          
        }

        // function for walking
        function Walk(e) {
          e.preventDefault();
          let oldPos = selectCat.position.clone();
          if (rightKey && selectCat.position.x < 16.5) {
            selectCat.position.x += 0.22;
            selectCat.rotation.y = 1.6;
            Collisions(oldPos);
          } else if (leftKey && selectCat.position.x > -16.5) {
            selectCat.position.x -= 0.22;
            selectCat.rotation.y = -1.6;
            Collisions(oldPos);
          } else if (upKey && selectCat.position.z > -26) {
            selectCat.position.z -= 0.22;
            selectCat.rotation.y = 3.2;
            Collisions(oldPos);
          } else if (downKey && selectCat.position.z < 7.5) {
            selectCat.position.z += 0.22;
            selectCat.rotation.y = 0;
            Collisions(oldPos);
          }
        }
        function Actions(e) {
          e.preventDefault();
          if (num == 1) {
            oLegL.rotation.x +=
              ((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.12;
            oLegR.rotation.x -=
              ((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.12;
            arm2.rotation.x -=
              ((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.1;
          } else if (num == 2) {
            blackKittybody.position.y = 0;
            blackKittybody.position.y +=
              ((Math.sin(Date.now() * 0.4) * Math.PI) / 2) * 0.01 * 6;
            shoulderl.rotation.z +=
              -2 * (((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.03);
            shoulderr.rotation.z -=
              -2 * (((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.03);
            bell.rotation.x -= -(
              ((Math.sin(Date.now() * 0.02) * Math.PI) / 2) *
              0.06
            );
            earl.rotation.z -=
              3 * (((Math.sin(Date.now() * 0.012) * Math.PI) / 2) * 0.001);
            earr.rotation.z +=
              3 * (((Math.sin(Date.now() * 0.012) * Math.PI) / 2) * 0.001);
            //leg movements
            legl.rotation.x +=
              ((Math.sin(Date.now() * 0.014) * Math.PI) / 2) * 0.12;
            legr.rotation.x -=
              ((Math.sin(Date.now() * 0.014) * Math.PI) / 2) * 0.12;
          } else if (num == 3) {
            // body
            whiteKittybody.position.y = 0;
            whiteKittybody.position.y += (Math.sin(Date.now() * 0.4) * Math.PI/2 * 0.01)*4;
            // legs
            wLegL.rotation.x += Math.sin(Date.now() * 0.014) * Math.PI/2 * 0.12;
            wLegR.rotation.x -= Math.sin(Date.now() * 0.014) * Math.PI/2 * 0.12;
            // arms 
            wShoulderL.rotation.z = THREE.Math.degToRad(135);
            wShoulderR.rotation.z = THREE.Math.degToRad(45);
            wShoulderL.rotation.z += -3*(Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.03);
            wShoulderR.rotation.z -= -3*(Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.03);
          }
        }

        document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;

        function Collisions(oldPos) {
          let otherKitty1, otherKitty2;
          if (num == 1) {
            otherKitty1 = blackKitty;
            otherKitty2 = whiteKitty;
          } else if (num == 2) {
            otherKitty1 = orangeKitty;
            otherKitty2 = whiteKitty;
          } else if (num == 3) {
            otherKitty1 = orangeKitty;
            otherKitty2 = blackKitty;
          }
          //for the background
          obstcls.forEach(function (obstcl) {
            if (
              selectCat.position.x <= obstcl.x + 2 &&
              selectCat.position.x >= obstcl.x - 2 &&
              selectCat.position.z <= obstcl.z + 2 &&
              selectCat.position.z >= obstcl.z - 2
            ) {
              selectCat.position.x = oldPos.x;
              selectCat.position.z = oldPos.z;
            }
          });
          //for the tree and the other 2 cats
          if(tree.position.y > 0.3){
            if(selectCat.position.x <= tree.position.x + 2.5 &&
                selectCat.position.x >= tree.position.x - 2.5 &&
                selectCat.position.z <= tree.position.z + 2.5 &&
                selectCat.position.z >= tree.position.z - 2.5){
                  selectCat.position.x = oldPos.x;
                  selectCat.position.z = oldPos.z;
                }
              }
              if((selectCat.position.x <= otherKitty1.position.x + 2 &&
                selectCat.position.x >= otherKitty1.position.x - 2 &&
                selectCat.position.z <= otherKitty1.position.z + 2 &&
                selectCat.position.z >= otherKitty1.position.z - 2) ||
              (selectCat.position.x <= otherKitty2.position.x + 2 &&
                selectCat.position.x >= otherKitty2.position.x - 2 &&
                selectCat.position.z <= otherKitty2.position.z + 2 &&
                selectCat.position.z >= otherKitty2.position.z - 2)
            ) {
              selectCat.position.x = oldPos.x;
              selectCat.position.z = oldPos.z;
            }
          //for the apple
          if (heart.position.y == -0.55) {
            if (
              selectCat.position.x <= heart.position.x - 2.5 + 1.2 &&
              selectCat.position.x >= heart.position.x - 2.5 - 1.2 &&
              selectCat.position.z <= heart.position.z + 2.5 + 1.2 &&
              selectCat.position.z >= heart.position.z + 2.5 - 1.2 
            ) {
              selectCat.position.x = oldPos.x;
              selectCat.position.z = oldPos.z;
            }
          }
        }

        // ----------------------------
        renderer.setAnimationLoop(render);
      };

      function render() {
        heartO.position.x = orangeKitty.position.x
        heartO.position.z = orangeKitty.position.z
        heartB.position.x = blackKitty.position.x
        heartB.position.z = blackKitty.position.z
        heartW.position.x = whiteKitty.position.x
        heartW.position.z = whiteKitty.position.z

        //heart animations for the end of the game
        heartO.position.y -= 0.04;
        heartO.scale.x = heartO.scale.z = heartO.scale.y += 0.015
        if(heartO.scale.x >= 1){
          heartO.position.y = 3
          heartO.scale.x = heartO.scale.z = heartO.scale.y = 0.1
        }
        heartB.position.y -= 0.04;
        heartB.scale.x = heartB.scale.z = heartB.scale.y += 0.015
        if(heartB.scale.x >= 1){
          heartB.position.y = 3
          heartB.scale.x = heartB.scale.z = heartB.scale.y = 0.1
        }
        heartW.position.y -= 0.04;
        heartW.scale.x = heartW.scale.z = heartW.scale.y += 0.015
        if(heartW.scale.x >= 1){
          heartW.position.y = 3
          heartW.scale.x = heartW.scale.z = heartW.scale.y = 0.1
        }


        arrowHelp.position.y -= (Math.sin(Date.now() * 0.008) * Math.PI/2 * 0.04)

        oEarL.rotation.x +=
          ((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.01;
        oEarR.rotation.x +=
          ((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.01; 
    
        //before starting
        if (!started) {
          camera.position.x -=
            ((Math.sin(Date.now() * 0.001) * Math.PI) / 2) * 0.02;
          indicator.rotation.y += 0.02;
          indicator.position.y +=
            ((Math.sin(Date.now() * 0.0025) * Math.PI) / 2) * 0.008;
        }

        if(waterTree){
          arm1.rotation.x +=
          ((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.03;
          setInterval(function(){
            arm1.rotation.x =0
            waterTree=false
          },2000)

        }

        if (toShake) {
        // let BBox = new THREE.Box3().setFromObject(heart);
        // bbHelper = new THREE.BoxHelper(heart, 0x00FFFF);
        // scene.add(bbHelper);
          shoulderl.rotation.y = THREE.Math.degToRad(60);
          shoulderr.rotation.y = THREE.Math.degToRad(-60);
          elbowl.rotation.z = -THREE.Math.degToRad(20);
          elbowr.rotation.z = THREE.Math.degToRad(20);
          earl.rotation.x +=
            6 * (((Math.sin(Date.now() * 0.015) * Math.PI) / 2) * 0.001);
          earr.rotation.x +=
            6 * (((Math.sin(Date.now() * 0.015) * Math.PI) / 2) * 0.001);
          blackKittybody.position.z +=
            ((Math.sin(Date.now() * 0.4) * Math.PI) / 2) * 0.01 * 3;
          tail.position.z +=
            ((Math.sin(Date.now() * 0.4) * Math.PI) / 2) * 0.01 * 3;
          bell.position.z +=
            ((Math.sin(Date.now() * 0.4) * Math.PI) / 2) * 0.01 * 3;
          bell.rotation.x -=
            -2 * (((Math.sin(Date.now() * 0.02) * Math.PI) / 2) * 0.06);
          tail.rotation.x = THREE.Math.degToRad(-90);
          treeTop.rotation.z =
            20 * (((Math.sin(Date.now() * 0.015) * Math.PI) / 2) * 0.001);

          setInterval(function () {
            shoulderl.rotation.z = THREE.Math.degToRad(20);
            shoulderr.rotation.z = THREE.Math.degToRad(-20);
            earl.rotation.z = earr.rotation.z = 0;

            tail.position.z = -0.7;
            bell.position.z = 0.7;
            blackKittybody.position.z = 0;
            tail.rotation.x = THREE.Math.degToRad(-70);
            earl.rotation.x = earr.rotation.x = 0;
            shoulderl.rotation.y = shoulderr.rotation.y = 0;
            elbowl.rotation.z = elbowr.rotation.z = 0;

            treeTop.rotation.z = 0;

            toShake = false;
          }, 1000);
        }

        if (toFall) {
          heart.rotation.x += THREE.Math.degToRad(5);
          if (heart.rotation.x >= THREE.Math.degToRad(90)) {
            heart.rotation.x = THREE.Math.degToRad(90);
          }
          heart.rotation.z += THREE.Math.degToRad(5);
          if (heart.rotation.z >= THREE.Math.degToRad(40)) {
            heart.rotation.z = THREE.Math.degToRad(40);
          }
          heart.position.y -= 0.1;
          if (heart.position.y <= -0.55) {
            heart.position.y = -0.55;
            toFall = false;
            setTimeout(() => {
              arrowHelp.position.x = -2;
              arrowHelp.position.z = 0;
              if(heart.position.y == -0.55){
                scene.add(arrowHelp)
              }
            }, 4000);
          }
          // let axesheart = new THREE.AxesHelper(4);
          // heart.add(axesheart);
        }

        // actions white
        if(toBend) {
          whiteKittybody.rotation.x = THREE.Math.degToRad(30)
          indicator.rotation.x = whiteKittybody.rotation.x;
          indicator.rotation.z = whiteKittybody.rotation.z;
          wShoulderR.rotation.x = THREE.Math.degToRad(-60);
          wShoulderR.rotation.y = THREE.Math.degToRad(-90);
          toBend = false;
          scene.remove(arrowHelp)
          
          setInterval(function() {
            toGrab = true;
          }, 1000)
        }
        
        if(toGrab) {
          whiteKittybody.rotation.x = THREE.Math.degToRad(0);
          indicator.rotation.x = whiteKittybody.rotation.x;
          indicator.rotation.z = whiteKittybody.rotation.z;
          scene.add(heart);
          wArmDownR.add(heart);
          heart.position.y = -4
          heart.position.z = 0.2
          heart.position.x = -0.8
          heart.rotation.x = heart.rotation.z = heart.rotation.y = 0
          toGrab = false;
          
          setInterval(function() {
            toEat = true;
          }, 1000)
        }

        if(toEat) {
          wElbowR.rotation.y += 0.1;
          if (wElbowR.rotation.y >= THREE.Math.degToRad(60)){
            wElbowR.rotation.y = THREE.Math.degToRad(60)
            setInterval(function(){
                heart.scale.set(0,0,0);
                wShoulderR.rotation.y = THREE.Math.degToRad(0); 
                wShoulderR.rotation.x = THREE.Math.degToRad(0); 
                wElbowR.rotation.y = THREE.Math.degToRad(0);
                toEat = false;
              },800); 
              setTimeout(() => {
                scene.add(heartO, heartB, heartW)
              }, 1400);
          }
        }

        //default movimentation

        blackKittybody.position.y +=
          ((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.002;
        tail.rotation.x -= ((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.01;
        shoulderl.rotation.z +=
          ((Math.sin(Date.now() * 0.009) * Math.PI) / 2) * 0.005;
        shoulderr.rotation.z -=
          ((Math.sin(Date.now() * 0.009) * Math.PI) / 2) * 0.005;
        bell.position.y +=
          ((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.0025;
        bell.position.z -=
          ((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.0025;
        bell.rotation.x += ((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.01;

        // orange
        earl.rotation.z -=
          ((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.0015;
        earr.rotation.z +=
          ((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.0015;
          orangeKitty.position.y +=
          ((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.002;
          
        // white cat movement 
        pointBell.rotation.z = 0
        pointBell.rotation.z = 0.3*(Math.cos(Date.now()*0.05*0.1));
        
        whiteKittybody.position.y +=
          ((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.002;
        wBell.position.z -=
          ((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.0025;
        wBell.rotation.x += 
          ((Math.sin(Date.now() * 0.01) * Math.PI) / 2) * 0.01;

        renderer.render(scene, camera);
        // controls.update();

        for (let i = 0; i < bg.geometry.attributes.position.count; i++) {
          let vprops = verts[i];
          let currentXposition = vprops.x + Math.cos(vprops.ang) * vprops.amp;
          let currentYposition = vprops.y + Math.sin(vprops.ang) * vprops.amp;
          vprops.ang += vprops.speed + 0.02;
          bg.geometry.attributes.position.setXY(
            i,
            currentXposition,
            currentYposition
          );
        }
        bg.geometry.attributes.position.needsUpdate = true;

        for (let i = 0; i < treeTop.geometry.attributes.position.count; i++) {
          let vpropsTree = vertsTree[i];
          let currentXpositionTree =
            vpropsTree.x + Math.cos(vpropsTree.ang) * vpropsTree.amp;
          let currentYpositionTree =
            vpropsTree.y + Math.sin(vpropsTree.ang) * vpropsTree.amp;
          vpropsTree.ang += vpropsTree.speed - 0.05;
          treeTop.geometry.attributes.position.setXY(
            i,
            currentXpositionTree,
            currentYpositionTree
          );
        }
        treeTop.geometry.attributes.position.needsUpdate = true;
      }
    </script>
  </body>
</html>
