<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>
        body{
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    
    <script type="module">
        import {OrbitControls} from './libs/OrbitControls.js'
        import * as THREE from './libs/three.module.js';
        import * as BufferGeometryUtils from './libs/BufferGeometryUtils.js';

        // const geometry = new BufferGeometry();
        let controls;

        let camera, scene, renderer, hello;
        
        window.onload = function init() {
            scene = new THREE.Scene();
            
            
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 100); // perspective camera
            // camera.position.x = 2;
            // camera.position.y = 3;
            // camera.position.z = 15;
            camera.position.z = 5;
            camera.position.x = 0;
            camera.position.y = 2;

            camera.lookAt(scene.position); //point the camera to the center of the scene
            
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight); // set output canvas and viewport size
            
            controls = new OrbitControls(camera, renderer.domElement);
            
            // configure renderer clear color
            renderer.setClearColor("#9BD4C3");
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // add the output of the renderer to an HTML element (adds a Canvas element to the body)
            document.body.appendChild(renderer.domElement);

            const axeHelper = new THREE.AxesHelper(5);
            scene.add(axeHelper);

        //----------------------------------------------------------------
// lights
            // let light = new THREE.AmbientLight(0xffffff, 0.7);
            let light = new THREE.AmbientLight(0xEAE178, 0.7);
            scene.add(light);

            let light2 = new THREE.PointLight(0xEAE178, 0.7);
            light2.position.set(-10, 5, 5);
            light2.castShadow = true;
            light2.shadow.camera;
            scene.add(light2);

            // light2.shadow.mapSize.width(2,2);
            // light2.shadow.mapSize.height(2,2);
            

            let light3 = new THREE.PointLight(0xEEBA77, 0.8);
            light3.position.set(5, 6, 5);
            scene.add(light3);
            // light helper
            let pointLightHelper = new THREE.PointLightHelper(light2, 0.4);
            let pointLightHelper1 = new THREE.PointLightHelper(light3, 0.4);
            // pointLightHelper.name = "helper";
            scene.add(pointLightHelper);
            scene.add(pointLightHelper1);

// ----------
// colors
const colorGreenShade = new THREE.MeshPhongMaterial({color: 0xA4C263, flatShading:true, shininess: 0});
        const colorGreen = new THREE.Color(0xA4C263);
        const colorBrown = new THREE.Color(0x8C7369);
        const colorBlack = new THREE.Color(0x494949);
        const colorWhite = new THREE.Color(0xF7F7F2);
        const colorPink = new THREE.Color(0xE8B5AC);
        const colorPurple = new THREE.Color(0xE1C5DD);
        const colorYellow = new THREE.Color(0xEAE178);

//pointer
            let geometry = new THREE.OctahedronGeometry( 1, 0)
            let pointer = new THREE.Mesh(geometry, colorGreenShade);
            pointer.position.y = 5;
            pointer.castShadow = true;
            scene.add(pointer);

// background

            let material = new THREE.MeshBasicMaterial({ color: 0x4b4b4b, wireframe: false });
            
            // ground
            geometry = new THREE.BoxGeometry(30, 0.5, 30)
            let plane = new THREE.Mesh(geometry, colorGreenShade);
            plane.position.y = -1;
            plane.position.z = -9;
            plane.receiveShadow = true;
            scene.add(plane);

//trees
            const bgGeometries = []

            const trunk = new THREE.BoxGeometry(1, 2, 1);

            const colorsTrunk = []; // array of colors for each vertex of the trunk geometry
            for (let i = 0; i < trunk.attributes.position.count; i++)
                colorsTrunk.push(colorBrown.r, colorBrown.g, colorBrown.b);
            // add color attribute to the trunk buffer geometry
            trunk.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunk), 3));

            bgGeometries.push(trunk);

            const level1 = new THREE.BoxGeometry(2.5, 2.5, 2.5);
            const colorsLevels = []; // array of colors for each vertex of the leaves geometry
            // Do this ONLY ONCE, since ALL 3 level bgGeometries have the SAME number of vertices
            for (let i = 0; i < level1.attributes.position.count; i++)
                colorsLevels.push(colorGreen.r, colorGreen.g, colorGreen.b);

            level1.translate(0, 2, 0)
            // add color attribute to the level1 buffer geometry
            level1.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLevels), 3));
            bgGeometries.push(level1);

            const level2 = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            level2.translate(1, 3, 0)
            // add color attribute to the level2 buffer geometry
            level2.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLevels), 3));
            bgGeometries.push(level2);

            const level3 = new THREE.BoxGeometry(2, 2, 2);
            level3.translate(-0.5, 3, 1)
            // add color attribute to the level3 buffer geometry
            level3.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLevels), 3));
            bgGeometries.push(level3);

            const bgGeometry = BufferGeometryUtils.mergeBufferGeometries(bgGeometries);
            const bg = new THREE.Mesh(
                bgGeometry,
                new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0})
            )
            const bg1 = new THREE.Mesh(
                bgGeometry,
                new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0})
            )
            bg.castShadow = true;
            bg.receiveShadow = true;
            bg.position.z = -5;
            scene.add(bg)
            bg1.castShadow = true;
            bg1.receiveShadow = true;
            bg1.position.x = -5; bg1.position.z = -3;
            scene.add(bg1)


// black cat

            const catGeometries = []

            const body = new THREE.BoxGeometry(1.5, 1, 1);
            const colorsBody = []; // array of colors for each vertex of the leaves geometry
            // Do this ONLY ONCE, since ALL 3 level catGeometries have the SAME number of vertices
            for (let i = 0; i < level1.attributes.position.count; i++)
                colorsBody.push(colorBlack.r, colorBlack.g, colorBlack.b);
    //body
            body.translate(0, 0.2, 0)
            // add color attribute to the body buffer geometry
            body.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBody), 3));
            catGeometries.push(body);

            const head = new THREE.BoxGeometry(2, 2, 1.6);
            head.translate(0, 1.7, 0)
            head.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBody), 3));
            catGeometries.push(head);

            const snout = new THREE.BoxGeometry(2, 1, 0.3);
            snout.translate(0, 1.2, 0.9)
            snout.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBody), 3));
            catGeometries.push(snout);

        //arms
            const arml = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            arml.translate(-0.78, 0.6, 0)
            arml.rotateZ(0.3,0.3,1);
            // add color attribute to the arml buffer geometry
            arml.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBody), 3));
            catGeometries.push(arml);

            const armr = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            armr.translate(0.78, 0.6, 0)
            armr.rotateZ(-0.3,0.3,1);
            armr.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBody), 3));
            catGeometries.push(armr);

         //ears
            const earl = new THREE.ConeGeometry(0.4,0.6,4,1);
            earl.translate(0.2, 2.9, 0.4);
            earl.rotateZ(0.3,0,0);
            earl.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBody), 3));
            catGeometries.push(earl);

            const earr = new THREE.ConeGeometry(0.4,0.6,4,1);
            earr.translate(-0.2, 2.9, 0.4);
            earr.rotateZ(-0.3,0,0);
            earr.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBody), 3));
            catGeometries.push(earr);


//white parts of body

    // legs
            const legl = new THREE.BoxGeometry(0.5, 0.5, 0.6);
            const colorsWhite = []; // array of colors for each vertex of the trunk geometry
            for (let i = 0; i < legl.attributes.position.count; i++)
                colorsWhite.push(colorWhite.r, colorWhite.g, colorWhite.b);
            legl.translate(-0.5, -0.55, 0)
            // add color attribute to the legl buffer geometry
            legl.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsWhite), 3));
            catGeometries.push(legl);

            const legr = new THREE.BoxGeometry(0.5, 0.5, 0.6);
            legr.translate(0.5, -0.55, 0)
            // add color attribute to the legr buffer geometry
            legr.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsWhite), 3));
            catGeometries.push(legr);
    //arms
            const forearml = new THREE.BoxGeometry(0.4, 0.5, 0.5);
            forearml.translate(-1.23, 0.6, 0);
            forearml.rotateZ(0.3,0.3,1);
            // add color attribute to the forearml buffer geometry
            forearml.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsWhite), 3));
            catGeometries.push(forearml);

            const forearmr = new THREE.BoxGeometry(0.4, 0.5, 0.5);
            forearmr.translate(1.23, 0.6, 0);
            forearmr.rotateZ(-0.3,0.3,1);
            // add color attribute to the forearmr buffer geometry
            forearmr.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsWhite), 3));
            catGeometries.push(forearmr);
    //details
            const forehead = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            forehead.translate(0, 2,3);
            // add color attribute to the forehead buffer geometry
            forehead.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsWhite), 3));
            // catGeometries.push(forehead);

            const blackCatGeometry = BufferGeometryUtils.mergeBufferGeometries(catGeometries);
            const blackCat = new THREE.Mesh(
                blackCatGeometry,
                new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0})
            )


            blackCat.castShadow = true;
            scene.add(blackCat)

    function handleKeyDown(e) {
    if (e.key == "f") {
        scene.traverse(function (child) {
            if (child instanceof THREE.Mesh && child.name == "") {
                child.material = new THREE.MeshPhysicalMaterial({
                        color: 0x2194ce
                        , flatShading: true, metalness: 1, roughness: 0.5,shininess:1
                });
            }
        });
    }
}
document.onkeydown = handleKeyDown;


// ----------------------------           
                renderer.setAnimationLoop(render);
            }
            
            function render(){
                // rotate the cube around its axes
                        // camera.rotation.y += 0.01;
                // cube.rotation.z += 0.1;
                // rectangle.position.x = 20;
                // hello.position.y = 2
                // hello.position.z = 10;
                // hello.rotation.x += 0.1;
            renderer.render(scene, camera);
            // controls.update();


        }
    </script>
</body>
</html>