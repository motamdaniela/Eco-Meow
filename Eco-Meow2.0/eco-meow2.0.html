<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>
        body{
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    
    <script type="module">
        import {OrbitControls} from './libs/OrbitControls.js'
        import * as THREE from './libs/three.module.js';
        import * as BufferGeometryUtils from './libs/BufferGeometryUtils.js';

        // const geometry = new BufferGeometry();
        let controls;
        let camera, scene, renderer;

        let keyPressed, rightKey, leftKey, upKey, downKey, toShake;
        let started = false;

        let heart, tree;
        
        let shoulderl, elbowl, shoulderr, elbowr;
        let legl, legr, armUpl, armUpr, forearml, forearmr, earl, earr, tail;
        let features, bell, blackKitty, blackKittybody, armsl, armsr;
        let bg, blackCat;
        let verts = []

        let initialRot =[]
        
        window.onload = function init() {
            scene = new THREE.Scene();
            
            
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 50); // perspective camera
            
            camera.position.z = 13;
            camera.position.x = 1;
            camera.position.y = 3;

            camera.lookAt(scene.position); //point the camera to the center of the scene
            
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight); // set output canvas and viewport size
            
            controls = new OrbitControls(camera, renderer.domElement);
            
            // configure renderer clear color
            renderer.setClearColor("#9BD4C3");
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // add the output of the renderer to an HTML element (adds a Canvas element to the body)
            document.body.appendChild(renderer.domElement);

            // const axeHelper = new THREE.AxesHelper(5);
            // scene.add(axeHelper);

        //----------------------------------------------------------------
// lights
            // let light = new THREE.AmbientLight(0xffffff, 0.7);
            let light = new THREE.AmbientLight(0xEAE178, 0.7);
            scene.add(light);

            let light2 = new THREE.PointLight(0xEAE178, 0.7, 100 );
            light2.position.set(-15, 6, 5);
            light2.castShadow = true;
            light2.shadow.camera;
            scene.add(light2);

            

            let light3 = new THREE.PointLight(0xEEBA77, 0.8,100);
            light3.position.set(5, 8, 5);
            scene.add(light3);
            // light helper
            let pointLightHelper = new THREE.PointLightHelper(light2, 0.4);
            let pointLightHelper1 = new THREE.PointLightHelper(light3, 0.4);
            // pointLightHelper.name = "helper";
            // scene.add(pointLightHelper);
            // scene.add(pointLightHelper1);

// ----------
// colors
const colorGreenShade = new THREE.MeshPhongMaterial({color: 0xA4C263, flatShading:true, shininess: 0});
        const colorGreen = new THREE.Color(0xA4C263);
        const colorBrown = new THREE.Color(0x8C7369);
        const colorRocks = new THREE.Color(0x9DA89A);
        const colorGray = new THREE.Color(0x494949);
        const colorBlack = new THREE.Color(0x000000);
        const colorWhite = new THREE.Color(0xF7F7F2);
        const colorPink = new THREE.Color(0xE8B5AC);
        const colorPurple = new THREE.Color(0x8F76D4);
        const colorYellow = new THREE.Color(0xEAE178);
        const colorRed = new THREE.Color(0xBD757E);

//pointer

            const heartl = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 6,6),
                new THREE.MeshStandardMaterial({ color: colorRed, flatShading: true, roughness: 0.4})
            );
            heartl.rotateZ(0.6,0,0);
            heartl.position.x = -0.35;
            heartl.position.y = 3.8;
            const heartr = heartl.clone();
            heartr.position.x = 0.35;
            heartr.rotateZ(-1.2,0,0)
            const heartbase = heartl.clone();
            heartbase.position.y = 3.45;
            heartbase.position.x = 0;
            heartbase.rotateZ(-0.6,0,0)

            const midl = new THREE.Mesh(
                new THREE.CylinderGeometry(0.499, 0.5, 0.5, 6),
                new THREE.MeshStandardMaterial({ color: colorRed, flatShading: true, roughness: 0.4})
            );
            midl.rotateZ(0.8,0,0);
            midl.rotateY(1.6,0,0);
            midl.position.x = -0.2;
            midl.position.y = 3.65;
            const midr = midl.clone();
            midr.rotateZ(-3.2,0,0);
            midr.rotateX(-1.6,0,0);
            midr.position.x = 0.2;

            
            heart = new THREE.Group();
            heart.add(heartl, heartr,heartbase, midl, midr);
            heart.position.y = 1;
            scene.add(heart);

// background
            
            // ground
            let geometry = new THREE.BoxGeometry(30, 1.5, 30)
            let plane = new THREE.Mesh(geometry, colorGreenShade);
            plane.position.y = -1.5;
            plane.position.z = -9;
            plane.receiveShadow = true;
            scene.add(plane);


            const treeGeometries = []                
            const colorTree = [];
                const treeupPart = new THREE.TorusGeometry(2.3,1.5,10,15);
                for (let i = 0; i < treeupPart.attributes.position.count; i++)
                colorTree.push(colorGreen.r, colorGreen.g, colorGreen.b);
                // add color attribute to the upPart buffer geometry
                treeupPart.setAttribute(
                    'color',
                    new THREE.BufferAttribute(new Float32Array(colorTree), 3));
                const treedownPart = new THREE.TorusGeometry(2.3,1.5,10,15);
                    treedownPart.setAttribute(
                        'color',
                        new THREE.BufferAttribute(new Float32Array(colorTree), 3));

            treeupPart.rotateX(1.6,0,0); treedownPart.rotateX(1.6,0,0);
            treedownPart.translate(0,4.5,0);treeupPart.translate(0,6,0);
            treeGeometries.push(treeupPart,treedownPart)
            
            const colorTreeTrunk = []
            const treeTrunk = new THREE.BoxGeometry(2.5, 5.5, 2.5);
            treeTrunk.translate(0,0.5,0)
            for (let i = 0; i < treeTrunk.attributes.position.count; i++)
            colorTreeTrunk.push(colorBrown.r, colorBrown.g, colorBrown.b);
            treeTrunk.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorTreeTrunk), 3));
            treeGeometries.push(treeTrunk);
                

                tree = new THREE.Mesh(
                   BufferGeometryUtils.mergeBufferGeometries(treeGeometries),
                   new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0})
               )
                tree.receiveShadow = tree.castShadow = true;
                tree.position.x = 4;
                scene.add(tree)

//backgroud--------------------------------------------------

            //rocks
            const bigRock = new THREE.Mesh(
                new THREE.TetrahedronGeometry(1,1),
                new THREE.MeshPhongMaterial({ color: colorRocks, flatShading: true,shininess: 0})
            );
            const smallRock = new THREE.Mesh(
                new THREE.TetrahedronGeometry(0.5,1),
                new THREE.MeshPhongMaterial({ color: colorRocks, flatShading: true,shininess: 0})
            );
            smallRock.rotateX(1.2,0,0)
            
            let smallRock1 = smallRock.clone();
            let bigRock1 = bigRock.clone();
            smallRock.position.x = 11;smallRock.position.z = -5; smallRock.position.y = smallRock1.position.y = -0.4;
            bigRock.position.x = 10;bigRock.position.z = -7; bigRock.position.y = bigRock.position.y = -0.3;
            smallRock1.position.x = -9; smallRock1.position.z = 5
            bigRock1.position.x = -12; bigRock1.position.z = -7

            let allRocks = new THREE.Group();
            allRocks.add(bigRock, smallRock, smallRock1, bigRock1);
            bigRock.castShadow = bigRock1.castShadow = smallRock.castShadow = smallRock1.castShadow = true;
            bigRock.receiveShadow = bigRock1.receiveShadow = smallRock.receiveShadow = smallRock1.receiveShadow = true;
            scene.add(allRocks);


//static bg elements------------
const staticGeometries = []
            const trunk1 = new THREE.BoxGeometry(3, 5, 3);

            const coloroftrunk = []
            for (let i = 0; i < trunk1.attributes.position.count; i++)
                coloroftrunk.push(colorBrown.r, colorBrown.g, colorBrown.b);
            // add color attribute to the trunk buffer geometry
            trunk1.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(coloroftrunk), 3));
            trunk1.translate(-6,1.5,-10)
            staticGeometries.push(trunk1);

            let trunk2 = trunk1.clone();
            let trunk3 = trunk1.clone();
            let trunk4 = trunk1.clone();
            
            trunk2.translate(22,0,-3);
            trunk3.translate(17,0,-8);
            trunk4.translate(9,0,-3);
            staticGeometries.push(trunk2, trunk3, trunk4);

            //boulders
                        // const rock = new THREE.TetrahedronGeometry(1,2);
            
                        // const colorsrock = []; // array of colors for each vertex of the rock geometry
                        // for (let i = 0; i < rock.attributes.position.count; i++)
                        //     colorsrock.push(colorRocks.r, colorRocks.g, colorRocks.b);
                        // // add color attribute to the rock buffer geometry
                        // rock.setAttribute(
                        //     'color',
                        //     new THREE.BufferAttribute(new Float32Array(colorsrock), 3));
                        // rock.translate(3,1,0);
                        // staticGeometries.push(rock);


            const staticGeometry = BufferGeometryUtils.mergeBufferGeometries(staticGeometries);
             let staticElements = new THREE.Mesh(
                staticGeometry,
                new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0})
            )
            staticElements.receiveShadow = true;
            staticElements.castShadow = true;
            staticElements.position.x = -5;
            staticElements.position.z = -4;
            scene.add(staticElements)

//bushes and leaves for trees(that move)
            const bgGeometries = []                
            const colorleaf = [];
                const upPart = new THREE.TorusGeometry(1.7,3,10,15);
                for (let i = 0; i < upPart.attributes.position.count; i++)
                colorleaf.push(colorGreen.r, colorGreen.g, colorGreen.b);
                // add color attribute to the upPart buffer geometry
                upPart.setAttribute(
                    'color',
                    new THREE.BufferAttribute(new Float32Array(colorleaf), 3));
                const downPart = new THREE.TorusGeometry(1.7,3,10,15);
                    downPart.setAttribute(
                        'color',
                        new THREE.BufferAttribute(new Float32Array(colorleaf), 3));

            upPart.rotateX(1.6,0,0); downPart.rotateX(1.6,0,0);
            upPart.translate(-6,7,-10); downPart.translate(-6,5.5,-10);
            let upPart2 = upPart.clone(); let upPart3 = upPart.clone();let upPart4 = upPart.clone();
            let downPart2 = downPart.clone(); let downPart3 = downPart.clone();let downPart4 = downPart.clone();
            
            upPart2.translate(22,0,-3); downPart2.translate(22,0,-3);
            upPart3.translate(17,0,-8); downPart3.translate(17,0,-8);
            upPart4.translate(9,0,-3);  downPart4.translate(9,0,-3);
            
            bgGeometries.push(upPart, downPart, upPart2, downPart2, upPart3, downPart3, upPart4, downPart4);
//bushes
            const bush = new THREE.SphereGeometry(1, 8, 5);
                    bush.setAttribute(
                        'color',
                        new THREE.BufferAttribute(new Float32Array(colorleaf), 3));
            bush.rotateZ(1.6,0,0);
            bush.translate(-9,-0.5,5);
            bgGeometries.push(bush);

            const bigBush = new THREE.SphereGeometry(1.7, 8, 5);
                    bigBush.setAttribute(
                        'color',
                        new THREE.BufferAttribute(new Float32Array(colorleaf), 3));
            bigBush.rotateX(1.6,0,0);
            bigBush.translate(-8,-0.5,3);
            bgGeometries.push(bigBush);

            const smallBush = new THREE.SphereGeometry(0.8, 8, 5);
                    smallBush.setAttribute(
                        'color',
                        new THREE.BufferAttribute(new Float32Array(colorleaf), 3));
            smallBush.rotateZ(1.2,0,0);
            smallBush.translate(-7,-0.5,5);
            bgGeometries.push(smallBush);

            let bigBush1 = bigBush.clone(), bigBush2 = bigBush.clone(), bigBush3 = bigBush.clone(), bigBush4 = bigBush.clone(), bigBush5 = bigBush.clone(),bigBush6 = bigBush.clone(),bigBush7 = bigBush.clone();
            bigBush1.translate(0,0,-10); bigBush2.translate(2,0,-20); bigBush3.translate(8,0,-17); bigBush4.translate(21,0,-18); bigBush5.translate(26.5,0,-18); bigBush6.translate(16,0,-21); bigBush7.translate(12,0,-19);
            bgGeometries.push(bigBush1, bigBush2, bigBush3, bigBush4, bigBush5, bigBush6, bigBush7);

            let bush1 = bush.clone(), bush2 = bush.clone(), bush3 = bush.clone(), bush4 = bush.clone();
            bush1.translate(5.5,0,-15); bush2.translate(18,0,-21); bush3.translate(14.5,0,-17); bush4.translate(23,0,-18);
            bgGeometries.push(bush1, bush2, bush3, bush4);

            let smallBush1 = smallBush.clone(), smallBush2 = smallBush.clone(), smallBush3 = smallBush.clone(), smallBush4 = smallBush.clone();
            smallBush1.translate(11,0,-16); smallBush2.translate(24,0,-16); smallBush3.translate(1,0,-13); smallBush4.translate(23,0,-18);
            bgGeometries.push(smallBush1, smallBush2, smallBush3, smallBush4);
            bush.translate(0,0,4); bigBush.translate(0,0,4); smallBush.translate(0,0,4);


            let bigBushes1 = bigBush.clone(), bigBushes2 = bigBush.clone();
            bigBushes1.translate(26,0,1); bigBushes2.translate(26,0,-12);
            bgGeometries.push(bigBushes1, bigBushes2);

            let Bushes1 = bush.clone(), Bushes2 = bush.clone();
            Bushes1.translate(28,0,-3); Bushes2.translate(0,0,-11);
            bgGeometries.push(Bushes1, Bushes2);

            let smallBushes1 = smallBush.clone(), smallBushes2 = smallBush.clone(), smallBushes3 = smallBush.clone();
            smallBushes1.translate(23,0,0); smallBushes2.translate(5,0,-1); smallBushes3.translate(22,0,-3);
            bgGeometries.push(smallBushes1, smallBushes2, smallBushes3);

//----------------------------------------------------------------

            const bgGeometry = BufferGeometryUtils.mergeBufferGeometries(bgGeometries);
             bg = new THREE.Mesh(
                bgGeometry,
                new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0})
            )
            bg.receiveShadow = true;
            bg.castShadow = true;
            bg.position.x = -5;
            bg.position.z = -4;
            scene.add(bg)


// black cat

            const catGeometries = []

            const body = new THREE.BoxGeometry(1.5, 1, 1);
            const colorsBody = []; // array of colors for each vertex of the leaves geometry
            // Do this ONLY ONCE, since ALL 3 level catGeometries have the SAME number of vertices
            for (let i = 0; i < body.attributes.position.count; i++)
                colorsBody.push(colorGray.r, colorGray.g, colorGray.b);
    //body
            body.translate(0, 0.2, 0)
            // add color attribute to the body buffer geometry
            body.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBody), 3));
            catGeometries.push(body);

            const head = new THREE.BoxGeometry(2.25, 1.7, 1.6);
            head.translate(0, 1.55, 0)
            head.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBody), 3));
            catGeometries.push(head);

            const snout = new THREE.BoxGeometry(2, 0.5, 0.3);
            snout.translate(0, 0.95, 0.9)
            snout.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBody), 3));
            catGeometries.push(snout);


//forehead
            const forehead = new THREE.BoxGeometry(0.84, 0.5, 1.62);
            const colorsWhite = [];
            for (let i = 0; i < forehead.attributes.position.count; i++)
                colorsWhite.push(colorWhite.r, colorWhite.g, colorWhite.b);
            forehead.translate(0, 2.16,0);
            forehead.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsWhite), 3));
            catGeometries.push(forehead);

//--> cheeks
            const cheekl = new THREE.BoxGeometry(0.4, 0.2, 0.1);
            const colorsPink = [];
            for (let i = 0; i < cheekl.attributes.position.count; i++)
                colorsPink.push(colorPink.r, colorPink.g, colorPink.b);
            cheekl.translate(-0.93, 0.81, 1.1)
            cheekl.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsPink), 3));
            catGeometries.push(cheekl);

            const cheekr = new THREE.BoxGeometry(0.4, 0.2, 0.1);
            cheekr.translate(0.93, 0.81, 1.1)
            cheekr.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsPink), 3));
            catGeometries.push(cheekr);

//colar
    const colar = new THREE.BoxGeometry(1.7, 0.5, 1.2);
            const colorsPurple = [];
            for (let i = 0; i < colar.attributes.position.count; i++)
                colorsPurple.push(colorPurple.r, colorPurple.g, colorPurple.b);
            colar.translate(0, 0.7, 0)
            colar.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsPurple), 3));
            catGeometries.push(colar);
                    
            //whiskers
            const whiskerl = new THREE.CylinderGeometry(0.06, 0.06, 0.5,4,1);
            const colorsBlack = [];
            for (let i = 0; i < whiskerl.attributes.position.count; i++)
                colorsBlack.push(colorBlack.r, colorBlack.g, colorBlack.b);
            whiskerl.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBlack), 3));
            whiskerl.translate(0.9, 1.2, 0.7);
            whiskerl.rotateZ(1.6,0,0);
            const whiskerl2 = whiskerl.clone()
            whiskerl2.translate(0,0.3,0)
            catGeometries.push(whiskerl,whiskerl2);

            const whiskerr = new THREE.CylinderGeometry(0.06, 0.06, 0.5,4,1);
            whiskerr.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBlack), 3));
            whiskerr.translate(0.9, -1.2, 0.7);
            whiskerr.rotateZ(1.6,0,0);
            const whiskerr2 = whiskerr.clone()
            whiskerr2.translate(0,0.3,0)
            catGeometries.push(whiskerr,whiskerr2);

//mesh/adding cat to scene           
            const blackCatGeometry = BufferGeometryUtils.mergeBufferGeometries(catGeometries);
            blackCat = new THREE.Mesh(
                blackCatGeometry,new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0})
            )
            blackCat.castShadow = true;
            blackCat.receiveShadow = true;

// eyes and nose and bell(shiny parts)
const shinyGeometries =[];
    const eyel = new THREE.SphereGeometry(0.25, 4,10);
    eyel.rotateX(1.6,0,0);
    eyel.rotateZ(0.8,0,0);
    eyel.translate(-0.7, 1.35, 0.7)
    const colorshinyBlack = [];
    for (let i = 0; i < eyel.attributes.position.count; i++)
        colorshinyBlack.push(colorBlack.r, colorBlack.g, colorBlack.b);
            eyel.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorshinyBlack), 3));
            shinyGeometries.push(eyel);

            const eyer = new THREE.SphereGeometry(0.25, 4,10);
            eyer.rotateX(1.6,0,0);
            eyer.rotateZ(0.8,0,0);
            eyer.translate(0.7, 1.35, 0.7)
            eyer.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorshinyBlack), 3));
            shinyGeometries.push(eyer);

        //lil nose
            const nose = new THREE.BoxGeometry(0.3, 0.1, 0.3);
            nose.translate(0, 1.1, 1)
            nose.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorshinyBlack), 3));
            shinyGeometries.push(nose);

            const shinyGeometry = BufferGeometryUtils.mergeBufferGeometries(shinyGeometries);
            features = new THREE.Mesh(
                shinyGeometry,new THREE.MeshPhysicalMaterial({ vertexColors: true, metalness:0.2, roughness:0.1, flatShading:true})
            )
            features.castShadow = true;
            features.receiveShadow = true;

// parts that move-----------------------------------------------------------------------------------------------------------------------

    // legs
    legl = new THREE.Mesh(
    new THREE.BoxGeometry(0.5, 0.7, 0.6),
    new THREE.MeshPhongMaterial({ color: colorWhite, flatShading: true, shininess: 0}));
    legl.position.x = -0.49;
    legl.position.y = -0.4;
    legl.receiveShadow = legl.castShadow = true;

    legr = new THREE.Mesh(
    new THREE.BoxGeometry(0.5, 0.7, 0.6),
    new THREE.MeshPhongMaterial({ color: colorWhite, flatShading: true, shininess: 0}));
    legr.position.x = 0.49;
    legr.position.y = -0.4;
    legr.receiveShadow = legr.castShadow = true;

//arms
            shoulderl = new THREE.Object3D();
            shoulderl.position.set(-0.7, 0.35, 0);
            shoulderl.rotation.z = THREE.Math.degToRad(20);
            scene.add(shoulderl);
            
  armUpl = new THREE.Mesh(
    new THREE.BoxGeometry(0.5, 0.5, 0.5),
    new THREE.MeshPhongMaterial({ color: colorGray, flatShading: true, shininess: 0}));
    armUpl.position.set(-0.25, 0, 0);
    // armUpl.rotateZ(0.3,0.3,1);
    shoulderl.add(armUpl)
    armUpl.receiveShadow = armUpl.castShadow = true;


    shoulderr = new THREE.Object3D();
            shoulderr.position.set(0.7, 0.35, 0);
            shoulderr.rotation.z = THREE.Math.degToRad(-20);
            scene.add(shoulderr);
            
    armUpr = new THREE.Mesh(
    new THREE.BoxGeometry(0.5, 0.5, 0.5),
    new THREE.MeshPhongMaterial({ color: colorGray, flatShading: true, shininess: 0}));
    armUpr.position.set(0.25, 0, 0);
    shoulderr.add(armUpr)
    armUpr.receiveShadow = armUpr.castShadow = true;
//forearms

            elbowl = new THREE.Object3D();
            elbowl.position.set(-0.25, 0, 0);
            armUpl.add(elbowl);

    forearml = new THREE.Mesh(
    new THREE.BoxGeometry(0.3, 0.5, 0.5),
    new THREE.MeshPhongMaterial({ color: colorWhite, flatShading: true, shininess: 0}));
    forearml.position.set(-0.15,0,0);
    elbowl.add(forearml);
    forearml.receiveShadow = forearml.castShadow = true;


            elbowr = new THREE.Object3D();
            elbowr.position.set(0.25, 0, 0);
            armUpr.add(elbowr);

    forearmr = new THREE.Mesh(
    new THREE.BoxGeometry(0.3, 0.5, 0.5),
    new THREE.MeshPhongMaterial({ color: colorWhite, flatShading: true, shininess: 0}));
    forearmr.position.set(0.15,0,0);
    elbowr.add(forearmr);
    forearmr.receiveShadow = forearmr.castShadow = true;

//  ears(rectangular)
            let leftEarG = [];
            let rightEarG = [];

            const outEarl = new THREE.BoxGeometry(0.7,0.4,0.7);
            outEarl.translate(-0.79, 2.6, 0.47)
            const colorGrayEar = [];
            for (let i = 0; i < outEarl.attributes.position.count; i++)
                colorGrayEar.push(colorGray.r, colorGray.g, colorGray.b);
            outEarl.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorGrayEar), 3));
            leftEarG.push(outEarl);

            const outEarr = new THREE.BoxGeometry(0.7,0.4,0.7);
            outEarr.translate(0.79, 2.6, 0.47)
            outEarr.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorGrayEar), 3));
            rightEarG.push(outEarr);

            const inEarl = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            inEarl.translate(-0.95, 2.3, 0.621)
            const colorPinkEar = [];
            for (let i = 0; i < inEarl.attributes.position.count; i++)
                colorPinkEar.push(colorPink.r, colorPink.g, colorPink.b);
            inEarl.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorPinkEar), 3));
            leftEarG.push(inEarl);

            const inEarr = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            inEarr.translate(0.95, 2.3, 0.621)
            inEarr.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorPinkEar), 3));
            rightEarG.push(inEarr);


            earl = new THREE.Mesh(
                BufferGeometryUtils.mergeBufferGeometries(leftEarG)
                ,new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0})
            )
            earl.castShadow = true;
            earl.receiveShadow = true;

            earr = new THREE.Mesh(
                BufferGeometryUtils.mergeBufferGeometries(rightEarG)
                ,new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0})
            )
            earr.castShadow = true;
            earr.receiveShadow = true;

//tail
            tail = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05,0.4,1,6),
                new THREE.MeshPhongMaterial({ color: colorGray, flatShading: true, shininess: 0})
            );
            tail.rotation.x = THREE.Math.degToRad(-70) 
            tail.position. y= 0.3;
            tail.position.z = -0.7;
            tail.castShadow = tail.receiveShadow = true;

// bell
            bell = new THREE.Mesh(
                new THREE.SphereGeometry(0.3,8,5),
                new THREE.MeshStandardMaterial({ color: colorYellow, flatShading: true, metalness:0.5, roughness:0.2})
            );
            bell.position.y = 0.3;
            bell.position.z = 0.7;
            bell.castShadow = true;
            bell.receiveShadow = true;

//group everything together
            blackKittybody = new THREE.Group();
            blackKittybody.add(blackCat, shoulderl, shoulderr, features, legl, legr, earl, earr);
            blackKitty = new THREE.Group();
            blackKitty.add(blackKittybody, bell,tail);
            scene.add(blackKitty);


//animations
            // SAVE initial vertices coordinates and settings for their circular motion
            for (let i = 0; i < bg.geometry.attributes.position.count; i++) {
                verts.push({
                    x: bg.geometry.attributes.position.getX(i),
                    y: bg.geometry.attributes.position.getY(i),

                    ang: Math.random() * Math.PI * 2,   // initial angle
                    amp: -0.1 + Math.random() * 0.2,        // radius
                    speed: 0.02 + Math.random() * 0.02  // angular velocity
                });
            }

            // initialRot.push({
            //     leglRot: leg.atributtes.rotation.getX(),
            // })

//------------------------

function handleKeyDown(e) {
    e.preventDefault();
    keyPressed = true
    if(!started){
        if(e.key == "Enter"){
            started = true;
            camera.position.set(1,3,13);
            camera.rotation.x = 0;
            heart.scale.y = heart.scale.x = heart.scale.z = 0;
        }else if(e.key == "1"){
            heart.position.x = -4;
        }else if(e.key == "2"){
            heart.position.x = 0;
        }else if(e.key == "3"){
            heart.position.x = 4;
        }

    }
    else if(started){
        if (e.key == "ArrowRight" && blackKitty.position.x < 14) {
            rightKey = true;
            Actions(e);
        }else if (e.key == "ArrowLeft" && blackKitty.position.x > -14) {
            leftKey = true;
            Actions(e);
        }else if (e.key == "ArrowUp" && blackKitty.position.z > -20) {
            upKey = true;
            Actions(e);
        }else if (e.key == "ArrowDown" && blackKitty.position.z < 5) {
            downKey = true;
            Actions(e);
        }else if (e.key == "s" 
        // && blackKitty.position <= tree.position -(4, 0, 4)
        ) {
            console.log(blackKitty.position <= tree.position - blackKitty.position);
            toShake = true
            shoulderl.rotation.y = THREE.Math.degToRad(60);
            shoulderr.rotation.y = THREE.Math.degToRad(-60);
            elbowl.rotation.z = -THREE.Math.degToRad(20);
            elbowr.rotation.z = THREE.Math.degToRad(20);


            earl.rotation.x += 6*(Math.sin(Date.now() * 0.015) * Math.PI/2 * 0.001);
            earr.rotation.x += 6*(Math.sin(Date.now() * 0.015) * Math.PI/2 * 0.001);
            blackKittybody.position.z += (Math.sin(Date.now() * 0.4) * Math.PI/2 * 0.01)*3
            tail.position.z += (Math.sin(Date.now() * 0.4) * Math.PI/2 * 0.01)*3;
            bell.position.z += (Math.sin(Date.now() * 0.4) * Math.PI/2 * 0.01)*3;
            bell.rotation.x -= -2*(Math.sin(Date.now() * 0.02) * Math.PI/2 * 0.06);
            tail.rotation.x = THREE.Math.degToRad(-90);
        }
    }
}

function handleKeyUp(e) {
    if (e.key == 'ArrowRight'){
		rightKey = false;
	}
	else if (e.key == 'ArrowLeft'){
		leftKey = false;
	}
	else if (e.key == 'ArrowUp'){
		upKey = false;
	}
	else if (e.key == 'ArrowDown'){
		downKey = false;
	}
    legl.rotation.x = legr.rotation.x = bell.rotation.x = 0;
    shoulderl.rotation.z = THREE.Math.degToRad(20);
    shoulderr.rotation.z = THREE.Math.degToRad(-20);
    earl.rotation.z = earr.rotation.z = 0;
    earl.rotation.x = earr.rotation.x = 0;
    blackKittybody.position.y = 0;

    tail.position.z = -0.7;
    bell.position.z = 0.7;
    blackKittybody.position.z = 0;
    tail.rotation.x = THREE.Math.degToRad(-70);
    earl.rotation.x = earr.rotation.x = 0;
    shoulderl.rotation.y = shoulderr.rotation.y = 0;
    elbowl.rotation.z = elbowr.rotation.z = 0;
}

// function for walking
function Actions(e){
    e.preventDefault();
    if (rightKey && blackKitty.position.x < 14) {
        blackKitty.position.x += 0.22;
        blackKitty.rotation.y = 1.6;
    }else if (leftKey && blackKitty.position.x > -14) {
        blackKitty.position.x -= 0.22;
        blackKitty.rotation.y = -1.6;
    }else if (upKey && blackKitty.position.z > -20) {
        blackKitty.position.z -= 0.22;
        blackKitty.rotation.y = 3.2;
    }else if (downKey && blackKitty.position.z < 5) {
        blackKitty.position.z += 0.22;
        blackKitty.rotation.y = 0;
    }
    // else if(toShake) {
    //     earl.rotation.x += 6*(Math.sin(Date.now() * 0.015) * Math.PI/2 * 0.001);
    //     earr.rotation.x += 6*(Math.sin(Date.now() * 0.015) * Math.PI/2 * 0.001);
    //     shoulderl.rotateX(1.6,0,0)
    // }
    blackKittybody.position.y = 0
    blackKittybody.position.y += (Math.sin(Date.now() * 0.4) * Math.PI/2 * 0.01)*6;
    shoulderl.rotation.z += -2*(Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.03);
    shoulderr.rotation.z -= -2*(Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.03);
    bell.rotation.x -= -(Math.sin(Date.now() * 0.02) * Math.PI/2 * 0.06);
    earl.rotation.z -= 3*(Math.sin(Date.now() * 0.012) * Math.PI/2 * 0.001);
    earr.rotation.z += 3*(Math.sin(Date.now() * 0.012) * Math.PI/2 * 0.001);
    //leg movements1
    legl.rotation.x += Math.sin(Date.now() * 0.014) * Math.PI/2 * 0.12;
    legr.rotation.x -= Math.sin(Date.now() * 0.014) * Math.PI/2 * 0.12;
}

document.onkeydown = handleKeyDown;
document.onkeyup = handleKeyUp;


//handler for keydown
// function ArrowPressed(e) {
// 			e.preventDefault();
// 			if (e.key == 'ArrowRight') {
// 				rightKey = true; //Canvas#2
// 			}
// 			else if (e.key == 'ArrowLeft'){
// 				leftKey = true; //Canvas#
// 			}
// 			else if (e.key == 'ArrowUp') {
// 				upKey = true; //Canvas#2
// 			}
// 			else if (e.key == 'ArrowDown'){
// 				downKey = true; //Canvas#
// 			}
// 			else if(e.keyCode==71){
// 				gKey = true;
// 			}
// 			else if(e.keyCode==80){
// 				sizex = 96/2
// 				sizey = 576/12
// 				if (!pKey){
// 					image.src = src2
// 				}
// 				pKey = true;
// 			}
// 		}
		
// 		//handler for keyup
// 		function ArrowReleased(e) {
// 			if (e.key == 'ArrowRight'){
// 				audio.volume = 0;
// 				rightKey = false;
// 				frameCol = 0;
// 			}
// 			else if (e.key == 'ArrowLeft'){
// 				audio.volume = 0;
// 				leftKey = false;
// 				frameCol = 0;
// 			}
// 			else if (e.key == 'ArrowUp'){
// 				audio.volume = 0;
// 				upKey = false;
// 				frameCol = 0;
// 			}
// 			else if (e.key == 'ArrowDown'){
// 				audio.volume = 0;
// 				downKey = false;
// 				frameCol = 0;
// 			}
// 		}
		
// 		//sets handlers for events keydown & keyup
// 		window.addEventListener('keydown', ArrowPressed);
// 		window.addEventListener('keyup', ArrowReleased);

// 		function actions(){
// 				if (rightKey){
// 					image.src = src
// 					audio.volume = 0.3;
// 					frameRow = 3;
// 					x+=10;
// 					frameCol++;	
// 					if (frameCol == 4)
// 					frameCol = 2;
					
// 				}
// 				else if (leftKey){
// 					image.src = src
// 				audio.volume = 0.3;
// 				x-=10;
// 				frameRow = 2;
// 				frameCol++;	
// 				if (frameCol == 4)
// 				frameCol = 0;
// 			}
// 			else if (upKey){
// 				image.src = src
// 				audio.volume = 0.3;
// 				y-=10;
// 				frameRow = 1;
// 				frameCol++;	
// 				if (frameCol == 3)
// 				frameCol = 0;
// 			}
// 			else if (downKey){
// 				image.src = src
// 				audio.volume = 0.3;
// 				y+=10;
// 				frameRow = 0;
// 				frameCol++;	
// 				if (frameCol == 4)
// 				frameCol = 0;
// 			}
// 			else if (gKey){
// 				frameCol++;	
// 				if (frameCol == 2){
// 					frameCol = 0;
// 					gKey = false;
// 				}
// 				grab(x,y)
// 			}
// 			else if (pKey){
// 				if (frameRow < 8){
// 					frameRow += 8
// 					frameCol = 2
// 				}
// 				frameCol--;	
// 				if (frameCol == -1){
// 					image.src = src
// 					pKey = false;
// 					frameCol = 0;
// 					sizex = 192/4
// 					sizey = 192/4
// 					frameRow -= 8
// 				}
// 				if(Math.floor(ecoCounter)/5 > 0){
// 					Plant();
// 				}
// 			}
// 		}

// ----------------------------           
                renderer.setAnimationLoop(render);
            }

            
            function render(){

            //before starting
            if(!started){
                // camera.position.y = 6
                // camera.position.x += 2*(Math.sin(Date.now() * 0.001) * Math.PI/2 * 0.02);
                // camera.lookAt(scene.position);
                heart.rotation.y += 0.02;
                heart.position.y += Math.sin(Date.now() * 0.0025) * Math.PI/2 * 0.008;
            }

            
            //movimentation of indicator
            // heart.scale.x = heart.scale.z = heart.scale.y +=  0.02
            // heart.position.y -= 0.06;
            // if(heart.scale.x >= 2){
            //     heart.scale.x = heart.scale.z = heart.scale.y =  1
            //     heart.position.y = 0
            // }

            if(!keyPressed){
                legl.rotation.x = legr.rotation.x = 0;
            }

            //default movimentation
            
                blackKittybody.position.y += Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.002;
                tail.rotation.x -= Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.01;
                shoulderl.rotation.z += Math.sin(Date.now() * 0.009) * Math.PI/2 * 0.005;
                shoulderr.rotation.z -= Math.sin(Date.now() * 0.009) * Math.PI/2 * 0.005;
                bell.position.y += Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.0025;
                bell.position.z -= Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.0025;
                bell.rotation.x += Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.01;
                earl.rotation.z -= Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.0015;
                earr.rotation.z += Math.sin(Date.now() * 0.01) * Math.PI/2 * 0.0015;
                

            renderer.render(scene, camera);
            // controls.update();


             // for all vertices of the cloud mesh
             for (let i = 0; i < bg.geometry.attributes.position.count; i++) {
                let vprops = verts[i];  // get INITIAL vertices and movement definitions
                // update X and Y values according to a 2D circular motion
                let currentXposition = vprops.x + Math.cos(vprops.ang) * vprops.amp;
                let currentYposition = vprops.y + Math.sin(vprops.ang) * vprops.amp;
                vprops.ang += vprops.speed +0.02; // update angle for next frame
                // set new X and Y coordinates for the vertex at the given index i
                bg.geometry.attributes.position.setXY(i, currentXposition, currentYposition);
            }
            // mandatory so that the new position values are rendered again
            bg.geometry.attributes.position.needsUpdate = true;

        }
    </script>
</body>
</html>